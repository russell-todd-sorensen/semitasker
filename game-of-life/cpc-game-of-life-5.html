<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<title>CPC-Game-Of-Life</title>
<link rel="stylesheet" href="https://home.semitasker.com/css/fonts.css" media="all">
<link rel="stylesheet" href="https://home.semitasker.com/css/log.css" media="all">
<style>
html,
body {
    background-color: black;
}

svg {
    fill: black;
}

#gameBoard rect2 {
    stroke: #555;
    stroke-width: .5px;
}
.cell-alive {
    /*fill: black; */
    fill: url(#rg1);
}

.cell-dead {
    fill: white;
}

#boardBoundary {
    stroke: #666;
    stroke-width: 2px;
    fill: none;
}

#controls {
    font-family: "Rubik";
    letter-spacing: -1px;
    color: black;
    background-color: white;
}

#controls ul {
    font-family: inherit;
    list-style: none;
    padding-top: 2px;
    padding-bottom: 2px;
}
#controls ul li {
    display: inline-block;
    width: 300px;
}
#controls li label {
    display: inline-block;
    width: 75px;
    padding: 2px;
    font-family: "Rubik";
    font-weight: bold;
}

#controls ul {
    position: relative;
}

#controls input[type="number"] {
    display: inline-block;
    font-family: "Rubik";
    font-size: 15px;
    width: 60px;
    text-align: right;
}

#controls #cellRx,
#controls #cellRy {
    width: 60px;
    text-align: right;
}

#controls select {
    display: inline-block;
    font-family: "Rubik";
    font-weight: bold;
    font-size: 16px;
    width: 174px;
    justify-self: right;
}


/* this is how you change the font of select options!!! */
#theory { /* select id */
    font-family: "Rubik";
    font-size: 16px;
}

#controls #fadeInColor,
#controls #fadeOutColor,
#controls #fadeEndColor {
    width: 170px;
    font-family: "Rubik";
    font-size: 16px;
}
#controls li {
    padding: 2px;
}
#controls #infinite-world {
    color: hsla(0,85%,25%,1.0);
    font-family: "Rubik";
    font-weight: bold;
}

#controls ul {
    width: 300px;
    display: inline-block;
    vertical-align: top;
}
.parity-cells button {
    height: 20px;
    width: 20px;
}
#controls #parity-cell-groups li.parity-cells-group {
    display: inline-block;
    width: auto;
}

#controls #parity-cell-groups thead {
    text-align: center;
}
</style>

<script src="/js/jquery-1.7.1.js"></script>
<script src="/js/d3.v3.js"></script>
<script src="/js/log-2.js"></script>

<script language="javascript">
if (false) {
var Log = {}
Log.Notice = function() {}
Log.Hide = function() {}
Log.Remove = function() {}
Log.Debug = function() {}
}

// included here to avoid loading https://home.semitasker.com/js/schedule-function.js 

function scheduleFunction(funcRef, timeout, rescheduleOnSuccessP, passArgsP, args) {

    if (arguments.length > 1) {
        if (timeout <= 0 ) {
            timeout = 10; //milliseconds
        }
    }
    else {
        var timeout = 10; //ms
    }

    if (arguments.length < 3) {
        var rescheduleOnSuccessP = false;
    }

    if (arguments.length > 3) {
        if (passArgsP) {
            var funcArgs = args;
        }
        else {
            var funcArgs = {};
        }
    }
    else {
        var passArgsP = false;
        var funcArgs = {};
    }

    var result = funcRef(funcArgs);
    Log.Notice("result=" + result + ", animationFunctionId=" + funcArgs.animationFunctionId)
    if (result.continueAnimation == false) {
        result = false;
    } 
    else if (result.timeout && !isNaN(parseInt(result.timeout))) {
        timeout = parseInt(result.timeout)
    }

    if (rescheduleOnSuccessP && result) {
        setTimeout(scheduleFunction, timeout,
            funcRef, timeout,
            rescheduleOnSuccessP,
            passArgsP, funcArgs);
    }
}

var GOLConfigs = [];

class GOLConfig {
    boardId    = "board"; // the parent id of the svg document
    gameId     = null;    // index in Games array
    svgId      = null;    // this.boardId + "-" + this.gameId;
    refRectId  = null;    // "ref-rect-" + this.gameId;
    gId        = null;    // this.boardID + "-r-" + this.gameId;
    xOffset    =  20;
    yOffset    =  30;
    width      = 150;     // number of cells wide
    height     =  75;     // number of cells high
    cellDim    =  15;     // this is the fixed grid size
    cellRx     = "25.0";  // in pixels or percent, must add % (with percent, rect becomes circle)
    cellRy     = "25.0";  // in pixels or percent, must add %
    cellWidth  = "15.0";  // in pixels (actual cell not grid, cells can overlap or be smaller than grid)
    cellHeight = "15.0";  // in pixels --^
    #randomInitArea = false; // private property, do not include this in options
    randomSeedValue = 0.14 // 14%
    options    = {};

    randomInitArea = {
        x:0, // starting column
        y:0, // starting row
        width: this.width,  // cols wide
        height: this.height, // rows high
    }

    constructor (options) {

        this.options = options;

        for (let key in options) { // only set valid object properties
            if (this[key]) {
                this[key] = options[key];
                if (key == "randomInitArea") {
                    this.#randomInitArea = true;
                }
            }
        }
        if (this.#randomInitArea == false) {
            this.randomInitArea.width  = this.width;
            this.randomInitArea.height = this.height;
        }
        if (this.gameId == null) {
            this.gameId = Games.length;
        }
        if (this.svgId == null) {
            this.svgId = "" + this.boardId + "-" + this.gameId;
        }
        if (this.refRectId == null) {
            this.refRectId = "ref-rect-" + this.gameId;
        }
        if (this.gId == null) {
            this.gId = this.boardId + "-g-" + this.gameId;
        }
    }

}

var showHint = function(hintId) {
    let animFId = parseInt($('#animationFunctionId option:selected').val());
    let hint = "";
    let pct = "14.00";
    switch (animFId) {
    case 1:
        hint = "Range: 40% to 60%"
        pct  = "45.00"
        $("#timeout").val(200);
        $("#fadeIn").val(1000);
        $("#fadeOut").val(1000);
        $("#fadeEnd").val(2000);
        break;
    case 2: 
    case 3: 
    case 4:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
        hint = "A few cells..."
        pct  = "0.0"
        $("#timeout").val(5000);
        $("#fadeIn").val(1000);
        $("#fadeOut").val(1000);
        $("#fadeEnd").val(3000);
        break;
    case 5:
    case 6:
        hint = "A few cells"
        pct  = "0.05"
        $("#timeout").val(5000);
        $("#fadeIn").val(1000);
        $("#fadeOut").val(1000);
        $("#fadeEnd").val(3000);
        break;
    case 0:
    default:
        hint = "14% is good start";
        pct  = "14.00"
        $("#timeout").val(100);
        $("#fadeIn").val(500);
        $("#fadeOut").val(1000);
        $("#fadeEnd").val(3000);
        break;
    }
    $("#" + hintId).text(hint);
    $('#randomSeedValue').val(pct);
}

var parityCellGroups = [];

class ParityCellGroup {
    labels25 = [
        "nwnw","nwn","nn","nen","nene",
        "nww", "nw", "n","ne","nee",
        "ww", "w", "c", "e", "ee",
        "sww", "sw", "s", "se", "see",
        "swsw", "sws", "ss", "ses", "sese"
    ];
    labels9 = [
        "nw","n","ne",
        "w", "c", "e",
        "sw", "s", "se" 
    ];
    values = [];
    labels = "labels9";
    size = 0;
    nwnw;nwn;nn;nen;nene;
    nww; nw; n; ne; nee;
    ww;  w;  c; e;  ee;
    sww; sw; s; se; see;
    swsw;sws;ss;ses;sese;
    
    constructor(groupName,size,values) {
        this.name = groupName;
        this.size = size?size:9;
        this.labels = this.size == 25 ? "labels25" : "labels9";
        this.setValues(values);
    }
    getLabels() {
        return this[this.labels];
    }
    getValue(dir) {
        return this[dir]?this[dir]:0;
    }
    getValueObjects() {
        let result = [],
            labels = this[this.labels];
        
        for (let i=0;i<this.size;i++) {
            if (this.values[i]) {
                result.push({dir:labels[i],val:this.values[i]});
            }
        }
        return result;
    }
    setValue(dir,value) {
        this[dir] = value;
    }
    setValues(values) {
        this.values = values?values:new Array(this.size).fill(0);
        let label = this[this.labels],
            labeldir;
        for (let i=0;i<this.size;i++) {
            labeldir = label[i];
            this[labeldir] = this.values[i] ;
        }
    }
    setFormValues(init) {
        let labels = this[this.labels]
        let len = labels.length,
            selector;
        for (let i=0;i<len;i++) {
            selector = "#parity-group-" + this.name + " #" + labels[i];
            $(selector).val(this.values[i]);
            document.querySelector(selector).innerText = this.values[i];
            if (init) {
                $(selector).bind("click", {group:this,i:i}, this.toggleCellValue);
            }
        }
    }
    getFormValues() {
        let labels = this[this.labels]
        let len = labels.length,
            selector;
        for (let i=0;i<len;i++) {
            selector = "#parity-group-" + this.name + " #" + labels[i];
            this.values[i] = $(selector).val();
        }
    }
    toggleCellValue(evt) {
        let data = evt.data,
            group = data.group, // local object 'this' covered
            index = data.i;

        group.values[index]++;

        if (group.values[index] == 2) {
            group.values[index] = -1
        }
        // Note: 'this' is the element clicked on!!
        this.value = group.values[index];
        this.innerText = this.value;
    }
}


window.addEventListener('DOMContentLoaded', () => {
    //gameInitWrap();
    //startAnimationPre();
    //showHint("hint");

    parityCellGroups[0] = new ParityCellGroup("rulea",9);
    parityCellGroups[1] = new ParityCellGroup("ruleb",9);
    parityCellGroups[2] = new ParityCellGroup("rulec",9);
    let len = parityCellGroups.length
    for (let i=0;i<len;i++) {
        parityCellGroups[i].setFormValues(true);
    }


});
</script>

</head>
<body>
<div id="board">

</div><!-- end of board -->

<div id="controls">
    <form id="controlsForm" onSubmit="return false;" spellcheck="false">
    <input type="hidden" name="gameId" id="gameId" value="0" />
    <ul>
    <fieldset>
    <legend>Game of Life Options</legend>
    <li>
     <label for="animationFunctionId">Anim Fn:</label>
     <select name="animationFunctionId" id="animationFunctionId" onChange="showHint('hint');">
      <option value="0" selected>Game Of Life</option>
      <option value="1">Majority Rule</option>
      <option value="2">One Out of Eight</option>
      <option value="3">Parity Rule</option>
      <option value="4">Parity Rule 2</option>
      <option value="7">Parity Rule 3</option>
      <option value="8">Parity Rule 4</option>
      <option value="9">Parity Rule 5</option>
      <option value="10">Parity Rule 6</option>
      <option value="11">Parity Rule 7</option>
      <option value="12">Parity Rule 8</option>
      <option value="13">Parity Rule 9</option>
      <option value="14">Parity Rule 10</option>
      <option value="15">Parity Rule A,B,C</option>
      <option value="5">North South</option>
      <option value="6">East West</option>
     </select>
    </li>
    <li>
    <label for="randomSeedValue">Living %:</label> <!-- alive percent -->
    <input type="number" name="randomSeedValue" id="randomSeedValue"
           value="14.00" min="0.00" max="100.00" step="0.05" />
           <span id="hint">This is a hint.</span>
    </li>
    <li>
    <label>Initialize:</label>
    <button id="infinite-world" onClick="gameInitWrap();">Infinite World!</button>
    <button id="finite-world" onClick="gameInit()">No Wrap.</button>
    </li>
    <li>
    <label >Animate:</label>
    <button onClick="startAnimationPre('gameId');">Start</button>
    <button onClick="startAnimationPre('gameId','round-robin');">Round Robin</button>
    <button onClick="stopAnimation('gameId');">Pause</button>
    </li>
    </fieldset>
    </ul>
    <ul>
    <fieldset>
    <legend>Timing Options</legend>
    <li>
    <label for="timeout">Step Time:</label>
    <input type="number" name="timeout" id="timeout" value="100" min="20" step="5" max="10000" /> ms
    </li>
    <li>
    <label for="fadeIn">Fade In:</label>
    <input type="number" name="fadeIn" id="fadeIn" value="500" min="0" step="10" max="10000" /> ms
    </li>
    <li>
    <label for="fadeOut">Fade Out:</label>
    <input type="number" name="fadeOut" id="fadeOut" value="1000" min="0" step="10" max="15000" /> ms
    </li>
    <li>
    <label for="fadeEnd">Fade End:</label>
    <input type="number" name="fadeEnd" id="fadeEnd" value="3000" min="0" step="10" max="15000" /> ms
    </li>
    </fieldset>
    </ul>
    <ul>
    <fieldset>
    <legend>Color Options</legend>
    <li>
    <label for="fadeInColor">Fade In:</label>
    <input type="text" name="fadeInColor" id="fadeInColor" value="hsla(0,85%,50%,0.75)" />
    </li>
    <li>
    <label for="fadeOutColor">Fade Out:</label>
    <input type="text" name="fadeOutColor" id="fadeOutColor" value="hsla(0,85%,70%,0.75)" />
    </li>
    <li>
    <label for="fadeEndColor">Fade End:</label>
    <input type="text" name="fadeEndColor" id="fadeEndColor" value="hsla(270,0%,20%,0.75)" />
    </li>
    <li>
    <label for="ease">Easing:</label>
    <select id="ease" name="ease" >
     <option value="linear">Linear</option>
     <option value="bounce">Bounce</option>
     <option value="bounce-in">Bounce In</option>
     <option value="bounce-out">Bounce Out</option>
     <option value="bounce-in-out">Bounce In/Out</option>
    </select>
    </li>
    </fieldset>
    </ul>
    <ul>
    <fieldset>
    <legend>Board Dimensions/Cell Shape</legend>
    <li>
    <label for="persist">Persist:</label>
    <input type="checkbox" name="persist" id="persist" value="true"/>
    </li>
    <li>
    <label for="cellsWide">Cells: </label>Wide:
    <input type="number" name="cellsWide" id="cellsWide" value="100" min="10" step="5" max="1500" />
    &nbsp;&nbsp;Width:
    <input type="number" name="cellWidth" id="cellWidth" value="14.0" min="1" step="0.1" max="150" />
    </li>
    <li>
    <label for="cellsHigh">Cells: </label>High:
    <input type="number" name="cellsHigh" id="cellsHigh" value="100" min="10" step="5" max="1500" />
    Height: 
    <input type="number" name="cellHeight" id="cellHeight" value="14.0" min="1" step="0.1" max="150" />
    </li>
    <li>
    <label>Radius:</label>
        <span class="radius">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X:
         <input type="text" name="cellRx" id="cellRx" value="3.0" min="0" step="1" max="100"/></span>
         <span class="radius">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y: 
         <input type="text" name="cellRy" id="cellRy" value="3.0" min="0" step="1" max="100"/></span>
    </li>
    </fieldset>
    </ul>
   <ul>
    <fieldset id="parity-cell-groups">
    <legend>Parity Cells Tri-State</legend>
    <li class="parity-cells-group">
        <table id="parity-group-rulea" class="parity-cells">
            <thead><tr><th colspan="3">Rule A</th></tr></thead>
            <tbody>
            <tr>
                <td><button id="nw" name="nw" value=""> </button></td>
                <td><button id="n" name="n" value=""> </button></td>
                <td><button id="ne" name="ne" value=""> </button></td>
            </tr>
            <tr>
                <td><button id="w" name="w" value=""> </button></td>
                <td><button id="c" name="c" value=""> </button></td>
                <td><button id="e" name="e" value=""> </button></td>
            </tr>
            <tr>
                <td><button id="sw" name="sw" value=""> </button></td>
                <td><button id="s" name="s" value=""> </button></td>
                <td><button id="se" name="se" value=""> </button></td>
            </tr>
            </tbody>
        </table>
    </li>
    <li class="parity-cells-group">
        <table id="parity-group-ruleb" class="parity-cells">
            <thead><tr><th colspan="3">Rule B</th></tr></thead>
            <tbody>
            <tr>
                <td><button id="nw" name="nw" value=""> </button></td>
                <td><button id="n" name="n" value=""> </button></td>
                <td><button id="ne" name="ne" value=""> </button></td>
            </tr>
            <tr>
                <td><button id="w" name="w" value=""> </button></td>
                <td><button id="c" name="c" value=""> </button></td>
                <td><button id="e" name="e" value=""> </button></td>
            </tr>
            <tr>
                <td><button id="sw" name="sw" value=""> </button></td>
                <td><button id="s" name="s" value=""> </button></td>
                <td><button id="se" name="se" value=""> </button></td>
            </tr>
            </tbody>
        </table>
    </li>
    <li class="parity-cells-group">
        <table id="parity-group-rulec" class="parity-cells">
            <thead><tr><th colspan="3">Rule C</th></tr></thead>
            <tbody>
            <tr>
                <td><button id="nw" name="nw" value=""> </button></td>
                <td><button id="n" name="n" value=""> </button></td>
                <td><button id="ne" name="ne" value=""> </button></td>
            </tr>
            <tr>
                <td><button id="w" name="w" value=""> </button></td>
                <td><button id="c" name="c" value=""> </button></td>
                <td><button id="e" name="e" value=""> </button></td>
            </tr>
            <tr>
                <td><button id="sw" name="sw" value=""> </button></td>
                <td><button id="s" name="s" value=""> </button></td>
                <td><button id="se" name="se" value=""> </button></td>
            </tr>
            </tbody>
        </table>
    </li>
    </fieldset>
    </ul>
    </form>
    </div>
<script>


var Games = new Array();
var animationFunctions = new Array();

class GameOfLifeCell {
    nw  = null;
    n   = null;
    ne  = null;
    w   = null;
    c   = null;
    sw  = null;
    s   = null;
    se  = null;
    id  = null;
    col = null;
    row = null;
    config = null;

    constructor(index,col,row,config) {
        this.id  = index?index:0;
        this.c   = this.id;
        this.col = col?col:0;
        this.row = row?row:0;
        this.config = config;
        return this;
    }
    toString() {
        return `id=${this.id}, col=${this.col}, row=${this.row}`;
    }
}

class gameOfLife {

    configId = null;
    config = null;
    width = 10;
    height = 10;
    cellCount = this.width * this.height;
    cellState = new Array(this.cellCount);
    neighborhood = new Array(this.cellCount);
    cellNeighbors = new Array(this.cellCount);
    wrap = true;
    continueAnimation = false;
    randomInitArea = null;
    directions = ['nw','n','ne','w','e','sw','s','se'];
    animationStep = 0;

    constructor (configId, wrap) {
        this.configId = configId;
        this.config = GOLConfigs[this.configId];
        this.width = this.config.width;
        this.height = this.config.height;
        this.cellCount = this.height*this.width;
        this.wrap = wrap?wrap:true;

        if (this.wrap) {
            this.initWrap();
        } else {
            this.init();
        }
        this.randomInitArea = this.config.randomInitArea?this.config.randomInitArea:{
            x:0,
            y:0,
            width:this.width,
            height:this.height,
        }
        this.randomSeedLimitedArea(this.config.randomSeedValue,this.randomInitArea);
    }

    init() {
        let cellIndex = 0,
            nb; // neighbor index array

        for (let row=0;row<this.height;row++) {
            for (let col=0;col<this.width;col++) {// note incr of cellIndex
                this.cellState[cellIndex] = 0;
                nb = new GameOfLifeCell(cellIndex,col,row,this.config);
                nb.c = cellIndex;
                if (row>0) {
                    if (col>0) {
                        nb.nw = cellIndex-this.width-1;
                    }
                    else {
                        nb.nw = null;
                    }
                    nb.n = cellIndex-this.width;
                    if (col<this.width-1) {
                        nb.ne = cellIndex-this.width+1;
                    }
                    else {
                        nb.ne = null;
                    }
                }
                else {
                    nb.nw = nb.n = nb.ne = null;
                }
                if (col>0) {
                    nb.w = cellIndex-1;
                }
                else {
                    nb.w = null;
                }
                if (col<this.width-1) {
                    nb.e = cellIndex+1;
                }
                else {
                    nb.e = null;
                }
                if (row<this.height-1) {
                    if (col>0) {
                        nb.sw = cellIndex+this.width-1;
                    }
                    else {
                        nb.sw = null;
                    }
                    nb.s = cellIndex+this.width;
                    if (col<this.width-1) {
                        nb.se = cellIndex+this.width+1;
                    }
                    else {
                        nb.se = null;
                    }
                }
                else {
                    nb.sw = nb.s = nb.se = null;
                }
                this.cellNeighbors[cellIndex] = nb;
                cellIndex++;
            }
        }
    }

    initWrap() {
        let cellIndex = 0,
            nb; // neighbor index array

        for (let row=0;row<this.height;row++) {
            for (let col=0;col<this.width;col++) {
                this.cellState[cellIndex] = 0;
                nb = new GameOfLifeCell(cellIndex,col,row,this.config);
                nb.c = cellIndex;

                if (row > 0 
                    && row < (this.height-1) 
                    && col > 0 
                    && col < (this.width-1)) 
                {
                    nb.nw = nb.c - this.width -1;
                    nb.n  = nb.nw + 1;
                    nb.ne = nb.n + 1;
                    nb.w  = nb.c -1;
                    nb.e  = nb.c + 1;
                    nb.sw = nb.c + this.width - 1;
                    nb.s  = nb.sw + 1;
                    nb.se = nb.s  + 1;
                    this.cellNeighbors[cellIndex] = nb;
                    cellIndex++;
                    continue;
                }

                if (row == 0) {
                    if (col == 0) { // upper left corner
                        nb.nw = this.cellCount -1;
                        nb.n  = this.cellCount - this.width;
                        nb.ne = nb.n + 1;
                        nb.w  = this.width -1;
                        nb.e  = nb.c + 1;
                        nb.sw = nb.w + this.width;
                        nb.s  = nb.c + this.width;
                        nb.se = nb.s + 1;
                    } 
                    else if (col == this.width-1) { // upper right corner
                        nb.nw = this.cellCount -2;
                        nb.n  = nb.nw + 1;
                        nb.ne = this.width * (this.height -1);
                        nb.w  = nb.c -1;
                        nb.e  = 0;
                        nb.sw = nb.c + this.width -1;
                        nb.s  = nb.sw + 1;
                        nb.se = nb.c + 1;
                    }
                    else { // rest of top row
                        nb.nw = this.width * (this.height-1) + col - 1;
                        nb.n  = nb.nw + 1;
                        nb.ne = nb.n + 1;
                        nb.w  = nb.c - 1;
                        nb.e  = nb.c + 1;
                        nb.sw = nb.c + this.width -1;
                        nb.s  = nb.sw + 1;
                        nb.se = nb.s + 1;
                    }
                }
                else if (row == this.height-1) {
                    if (col == 0) { // lower left corner
                        nb.nw = nb.c -1;
                        nb.n  = nb.c - this.width;
                        nb.ne = nb.n + 1;
                        nb.w  = nb.c + this.width -1;
                        nb.e  = nb.c + 1;
                        nb.sw = this.width -1;
                        nb.s  = 0;
                        nb.se = 1;
                    }
                    else if (col == this.width-1) { // lower right corner
                        nb.nw = nb.c - this.width - 1;
                        nb.n  = nb.nw + 1;
                        nb.ne = nb.n - this.width + 1;
                        nb.w  = nb.c -1;
                        nb.e  = nb.ne + this.width;
                        nb.sw = this.width -2;
                        nb.s  = nb.sw + 1;
                        nb.se = 0;
                    } else { // rest of bottom row
                        nb.nw = nb.c - this.width -1;
                        nb.n  = nb.nw + 1;
                        nb.ne = nb.n  + 1;
                        nb.w  = nb.c  - 1;
                        nb.e  = nb.c  + 1;
                        nb.sw = col   - 1;
                        nb.s  = nb.sw + 1;
                        nb.se = nb.s  + 1;
                    }
                } 
                else {
                    if (col == 0) { // rest of left-most column
                        nb.nw = nb.c  - 1;
                        nb.n  = nb.c  - this.width;
                        nb.ne = nb.n  + 1;
                        nb.w  = nb.c  + this.width -1;
                        nb.e  = nb.c  + 1;
                        nb.sw = nb.c  + (this.width*2) -1;
                        nb.s  = nb.c  + this.width;
                        nb.se = nb.s  + 1;
                    }
                    else if (col == this.width -1) { // rest of right-most column
                        nb.nw = nb.c  - this.width -1;
                        nb.n  = nb.nw + 1;
                        nb.ne = nb.n  - this.width + 1;
                        nb.w  = nb.c  - 1;
                        nb.e  = nb.n  + 1;
                        nb.sw = nb.c  + this.width -1;
                        nb.s  = nb.sw + 1;
                        nb.se = nb.c  + 1;
                    }
                }

                this.cellNeighbors[cellIndex] = nb;
                cellIndex++;
            }
        }
    }
    randomSeed(percent) {
        for (let i = 0; i<this.cellCount;i++) {
            this.cellState[i] = (Math.random() <= percent ? 1 : 0);
        }
    }
    
    randomSeedLimitedArea(percent,initArea) {

        initArea = initArea?initArea:this.initArea;

        for (let row=initArea.y;row<initArea.y+initArea.height;row++) {
            for (let col=initArea.x;col<initArea.x+initArea.width;col++) {
                let i = (this.width *(row -1) + col);
                this.cellState[i] = (Math.random() <= percent ? 1 : 0);
            }
        }
        return;
    };

    pollNeighbors() {
        let total,
            dir,
            cell;
        for (let i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = 0;
            for (let d in this.directions) {
                dir = this.directions[d];
                if (cell[dir] == null) continue;
                total += this.cellState[cell[dir]];
            }
            this.neighborhood[i] = total;
        }
    }
    pollNeighborParity() {
        let cell,
            total,
            parity;
        for (var i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = this.cellState[i];
            if (cell['s'] != null)
                total += this.cellState[cell['s']];
            if (cell['w'] != null)
                total += this.cellState[cell['w']];
            if (cell['n'] != null)
                total += this.cellState[cell['n']];
            if (cell['e'] != null)
                total += this.cellState[cell['e']];

            parity = total%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborParity2() {
        let cell,
            total,
            parity;
        for (var i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = this.cellState[i];
            if (cell['sw'] != null)
                total += this.cellState[cell['sw']];
            if (cell['nw'] != null)
                total += this.cellState[cell['nw']];
            if (cell['ne'] != null)
                total += this.cellState[cell['ne']];
            if (cell['se'] != null)
                total += this.cellState[cell['se']];

            parity = total%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborParity3() {
        let cell,
            total,
            parity;
        for (var i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = this.cellState[i];
            if (cell['sw'] != null)
                total += this.cellState[cell['sw']];
            if (cell['nw'] != null)
                total += this.cellState[cell['nw']];
            if (cell['ne'] != null)
                total += this.cellState[cell['ne']];
            if (cell['se'] != null)
                total += this.cellState[cell['se']];
            if (cell['s'] != null)
                total += this.cellState[cell['s']];
            if (cell['w'] != null)
                total += this.cellState[cell['w']];
            if (cell['n'] != null)
                total += this.cellState[cell['n']];
            if (cell['e'] != null)
                total += this.cellState[cell['e']];

            parity = total%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborParity4() {
        let cell,
            total,
            parity;
        for (let i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = this.cellState[i];
            if (cell['sw'] != null)
                total += this.cellState[cell['sw']];
            if (cell['nw'] != null)
                total += this.cellState[cell['nw']];
            if (cell['e'] != null)
                total += this.cellState[cell['e']];

            parity = total%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborParity5() {
        let cell,
            total,
            parity;
        for (let i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = this.cellState[i];
            if (cell['sw'] != null)
                total += this.cellState[cell['sw']];
            if (cell['nw'] != null)
                total += this.cellState[cell['nw']];
            if (cell['se'] != null)
                total += this.cellState[cell['se']];
            if (cell['s'] != null)
                total += this.cellState[cell['s']];

            parity = total%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborParity6() {
        let cell,
            total,
            parity;
        for (let i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = this.cellState[i];
            if (cell['nw'] != null)
                total += this.cellState[cell['nw']];
            if (cell['ne'] != null)
                total += this.cellState[cell['ne']];
            if (cell['s'] != null)
                total += this.cellState[cell['s']];
            if (cell['n'] != null)
                total += this.cellState[cell['n']];
            parity = total%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborParity7() {
        let cell,
            total,
            parity;
        for (let i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = this.cellState[i];
            if (cell['sw'] != null)
                total += this.cellState[cell['sw']];
            if (cell['nw'] != null)
                total += this.cellState[cell['nw']];
            if (cell['se'] != null)
                total += this.cellState[cell['se']];
            if (cell['s'] != null)
                total += this.cellState[cell['s']];
            if (cell['w'] != null)
                total += this.cellState[cell['w']];

            parity = total%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborParity8() {
        var cell,total,parity;
        for (let i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = this.cellState[i];
            if (cell['n'] != null)
                total += this.cellState[cell['n']];
            if (cell['e'] != null)
                total += this.cellState[cell['e']];
            if (cell['s'] != null)
                total += this.cellState[cell['s']];
            if (cell['w'] != null)
                total += this.cellState[cell['w']];

            parity = total%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborParity9() {
        let cell,
            total,
            parity;
        for (let i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = this.cellState[i];
            if (cell['n'] != null)
                total += this.cellState[cell['n']];
            if (cell['e'] != null)
                total -= this.cellState[cell['e']]; // note -= 
            if (cell['s'] != null)
                total += this.cellState[cell['s']];
            if (cell['w'] != null)
                total += this.cellState[cell['w']];

            parity = total%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborParity10() {
        let cell,
            total,
            parity;
        for (let i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = this.cellState[i];
            total = 0; // this deletes the middle cell
            if (cell['sw'] != null)
                total += this.cellState[cell['sw']];
            if (cell['nw'] != null)
                total += this.cellState[cell['nw']];
            if (cell['ne'] != null)
                total += this.cellState[cell['ne']];
            if (cell['se'] != null)
                total += this.cellState[cell['se']];
            if (cell['s'] != null)
                total += this.cellState[cell['s']];
            if (cell['w'] != null)
                total += this.cellState[cell['w']];
            if (cell['n'] != null)
                total -= this.cellState[cell['n']];// deletes south
            if (cell['e'] != null)
                total += this.cellState[cell['e']]; // deletes west

            parity = total%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborNorthSouth1() {
        let cell,
            parity
            totalNorthSouth,
            totalEastWest;
        for (let i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            totalNorthSouth = this.cellState[i];
            if (cell['s'] != null)
                totalNorthSouth += this.cellState[cell['s']];
            if (cell['n'] != null)
                totalNorthSouth += this.cellState[cell['n']];
            totalEastWest = this.cellState[i];
            if (cell['e'] != null)
                totalEastWest += this.cellState[cell['e']];
            if (cell['w'] != null)
                totalEastWest += this.cellState[cell['w']];

            parity = (totalNorthSouth-totalEastWest)%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborNorthSouth2() {
        let cell,
            parity
            totalNorthSouth,
            totalEastWest;
        for (var i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            totalNorthSouth = this.cellState[i];
            if (cell['s'] != null)
                totalNorthSouth += this.cellState[cell['s']];
            if (cell['n'] != null)
                totalNorthSouth += this.cellState[cell['n']];
            totalEastWest = this.cellState[i];
            if (cell['e'] != null)
                totalEastWest += this.cellState[cell['e']];
            if (cell['w'] != null)
                totalEastWest += this.cellState[cell['w']];

            parity = (totalEastWest-totalNorthSouth)%2;
            this.neighborhood[i] = parity;
        }
    }
    pollNeighborGeneric(pollDirections) {

        let total,
            d,
            dir,
            cell,
            parity,
            val;
        for (let i=0;i<this.cellCount;i++) {
            cell = this.cellNeighbors[i];
            total = 0;
            for (let j=0;j<pollDirections.length;j++) {
                d = pollDirections[j]
                dir = d.dir;
                val = d.val;
                switch (val) {
                case 0: 
                    break;
                case 1: 
                    total += this.cellState[cell[dir]];
                    break;
                case -1: 
                    total -= this.cellState[cell[dir]];
                    break;
                }
            }
            parity = total%2;
            this.neighborhood[i] = parity;
        }
    }
}

function createGameBoard(configId) {
 
    let config = GOLConfigs[configId]
    let board = document.getElementById(config.boardId);

    let
        svgWidth = config.cellDim*config.width + 2*config.xOffset,
        svgHeight = config.cellDim*config.height + 2*config.yOffset,
        viewBox   = [0,0,svgWidth,svgHeight].join(" ");

    board.innerHTML = `<svg 
    id="${config.svgId}"
    xmlns:svg="http://www.w3.org/2000/svg"
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    version="1.0"
    x="0"
    y="0"
    width="${svgWidth}"
    height="${svgHeight}"
    viewBox="${viewBox}">
<defs>
 <rect id="${config.refRectId}" height="${config.cellHeight}"
       width="${config.cellWidth}" rx="${config.cellRx}"
       ry="${config.cellRy}" />
</defs>
<g id="${config.gId}"></g>
</svg>`

    let g = d3.select('#' + config.gId);

    g.selectAll('use')
        .data(Games[config.gameId].cellNeighbors)
        .enter()
        .append('use')
        .attr('id',function(d,i) {return 'c-' + i;})
        .attr('xlink:href',"#" + config.refRectId)
        .attr('x', function(d,i) {
            let col = i%d.config.width;
            return col*d.config.cellDim + d.config.xOffset;
        })
        .attr('y', function(d,i) {
            let row = Math.floor(i/d.config.width);
            return row*d.config.cellDim + d.config.yOffset;
        })
        .attr('fill', function (d,i) {
            if (Games[d.config.gameId].cellState[i] == 1) {
                return d.config.options.fadeInColor;
            } else {
                return 'hsla(0,0%,0%,1.0)';
            }
         })
        .on('mouseover', function (d,i) {
            let cell = d3.select(this),
                cellId = cell.attr('id'),
                idList = cellId.split('-'),
                id = parseInt(idList[1]);
            d3.select("#cellNumber").text(i);
            d3.select('#cellNeighbors').text(Games[d.config.gameId].cellNeighbors[i]);
        })
        .on('click', function (d,i) {
            let gameId = d.config.gameId,
                myGame = Games[gameId];

            if (myGame.cellState[i] == 1) {
                cellDie(d.config.options,i);
            } else {
                cellAlive(d.config.options,i);
            }
        })
        .on('mouseout', function (d,i) {

        });

    g.append('rect')
        .attr('x',config.xOffset)
        .attr('y',config.yOffset)
        .attr('height',config.cellDim*config.height)
        .attr('width',config.cellDim*config.width)
        .attr('id','boardBoundary');

}

////////////////// LIVE AND DIE FUNCTIONS ////////////

function cellDie (data,id) {

    let gameId = data.gameId,
        myGame = Games[gameId];

    d3.select('#c-' + id)
        .transition()
        .ease(data.ease)
        .duration(data.fadeOut)
        .attr('fill',data.fadeOutColor)
        .each('end', function (d,i) {
            if (data.persist) {
                return;
            }
            let cell = d3.select(this);
            cell
                .transition()
                .ease(data.ease)
                .duration(data.fadeEnd)
                .attr('fill',data.fadeEndColor);
        });

    myGame.cellState[id] = 0;
}

function cellAlive (data,id) {

    let gameId = data.gameId,
        myGame = Games[gameId];

    d3.select('#c-' + id)
        .transition()
        .ease(data.ease)
        .duration(data.fadeIn)
        .attr('fill',data.fadeInColor);

    myGame.cellState[id] = 1;
}

var neighborDataRules = [];


neighborDataRules["all"] = [
    [
        {dir:"nw",val:1},
        {dir:"n",val:1},
        {dir:"ne",val:1},
        {dir:"w",val:1},
        {dir:"c",val:1},
        {dir:"e",val:1},
        {dir:"sw",val:1},
        {dir:"s",val:1},
        {dir:"se",val:1},
    ],
]

animationFunctions[0] = function (data) {

    let gameId = data.gameId,
        myGame = Games[gameId];

    myGame.pollNeighbors();

    for (var i=0;i<myGame.cellCount;i++) {
        if (myGame.cellState[i] == 1) { // alive
            switch (myGame.neighborhood[i]) {
            case 2:
            case 3:
                break;
            default:
                cellDie(data,i);
                break;
            }
        }
        else { // dead
            switch (myGame.neighborhood[i]) {
            case 3:
                cellAlive(data,i);
                break;
            default:
                break;
            }
        }
    }

    return myGame.continueAnimation;
}

animationFunctions[1] = function (data) {

    let gameId = data.gameId,
        myGame = Games[gameId];

    myGame.pollNeighbors();

    for (var i=0;i<myGame.cellCount;i++) {
        switch (myGame.neighborhood[i]) {
        case 0:
        case 1:
        case 2:
        case 3:
            if (myGame.cellState[i] == 1) { // alive
                cellDie(data,i);
            }
            break;
        case 4:
            break; // no change
        case 5:
        case 6:
        case 7:
        case 8:
            if (myGame.cellState[i] == 0) { // dead
                cellAlive(data,i);
            }
            break;
        }
    }

    return myGame.continueAnimation;
}

animationFunctions[2] = function (data) { // one-out-of-eight

    let gameId = data.gameId,
        myGame = Games[gameId];

    myGame.pollNeighbors();

    for (var i=0;i<myGame.cellCount;i++) {
        switch (myGame.neighborhood[i]) {
        case 1:
            if (myGame.cellState[i] == 0) { 
                cellAlive(data,i);
            }
            break;
        default:
            break;
        }
    }

    return myGame.continueAnimation;
}

animationFunctions[3] = function (data) { // parity rule

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborParity();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i);
        } else {
            cellDie(data,i);
        }
    }
    return myGame.continueAnimation;
}

animationFunctions[4] = function (data) { // parity rule 2

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborParity2();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i);
        } else {
            cellDie(data,i);
        }
    }
    return myGame.continueAnimation;
}

animationFunctions[7] = function (data) { // parity rule 3

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborParity3();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i);
        } else {
            cellDie(data,i);
        }
    }
    return myGame.continueAnimation;
}

animationFunctions[8] = function (data) { // parity rule 4

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborParity4();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i);
        } else {
            cellDie(data,i);
        }
    }
    return myGame.continueAnimation;
}

animationFunctions[9] = function (data) { // parity rule 5

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborParity5();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i);
        } else {
            cellDie(data,i);
        }
    }
    return myGame.continueAnimation;
}

animationFunctions[10] = function (data) { // parity rule 6

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborParity6();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i);
        } else {
            cellDie(data,i);
        }
    }
    return myGame.continueAnimation;
}

animationFunctions[11] = function (data) { // parity rule 7

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborParity7();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i);
        } else {
            cellDie(data,i);
        }
    }
    return myGame.continueAnimation;
}

animationFunctions[12] = function (data) { // parity rule 8

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborParity8();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i);
        } else {
            cellDie(data,i);
        }
    }
    return myGame.continueAnimation;
}

animationFunctions[13] = function (data) { // parity rule 9

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborParity9();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i);
        } else {
            cellDie(data,i);
        }
    }
    return myGame.continueAnimation;
}

animationFunctions[14] = function (data) { // parity rule 10

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborParity10();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i); 
        } else {
            cellDie(data,i);
        }
    }
    return myGame.continueAnimation;
}

animationFunctions[5] = function (data) { // north south 1

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborNorthSouth1();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i);
        } else {
            cellDie(data,i);
        }
    }

    return myGame.continueAnimation;
}
animationFunctions[6] = function (data) { // north south 2

    let gameId = data.gameId,
        myGame = Games[gameId],
        parity;

    myGame.pollNeighborNorthSouth2();

    for (var i=0;i<myGame.cellCount;i++) {
        parity = myGame.neighborhood[i];
        if (parity == myGame.cellState[i]) {
            continue; // no change in state;
        } else if (parity == 1) {
            cellAlive(data,i);
        } else {
            cellDie(data,i);
        }
    }

    return myGame.continueAnimation;
}

animationFunctions[15] = function (data) { // generic parity rule

    let gameId = data.gameId,
        myGame = Games[gameId],
        ruleABC = data.ruleABC,
        len = ruleABC.length,
        parity;
    for (let j=0;j<len;j++) {
        if (data.roundRobin && myGame.animationStep%len != j) {
            continue;
        }
        myGame.pollNeighborGeneric(ruleABC[j]);

        for (var i=0;i<myGame.cellCount;i++) {
            parity = myGame.neighborhood[i];
            if (parity == myGame.cellState[i]) {
                continue; // no change in state;
            } else if (parity == 1) {
                cellAlive(data,i);
            } else {
                cellDie(data,i);
            }
        }
    }
    myGame.animationStep++;
    return myGame.continueAnimation;
}

var startAnimationPre = function(formGameId,roundRobin) {

    let gameId = parseInt($('#' + formGameId).val()),
        options = Games[gameId].config.options,
        animationFunctionId =options.animationFunctionId,
        timeout = options.timeout;
        options.roundRobin = roundRobin?true:false;
        if (options.roundRobin) {
            Games[gameId].animationStep = 0;
        } 

    startAnimation(animationFunctionId,timeout,options);
}

var startAnimation = function (animationFunctionId,timeout, options) {
    let gameId = options.gameId,
        myGame = Games[gameId],
        animationFunction = animationFunctions[animationFunctionId];

    myGame.continueAnimation = true;

    if (timeout < 10) timeout = 10;

    scheduleFunction(animationFunction, timeout, true, true, options);
};

var stopAnimation = function(formGameId) {
    let gameId = parseInt($('#' + formGameId).val());
    let myGame = Games[gameId]

    myGame.continueAnimation = false;
};

var processGameOfLifeForm = function () {

    let gameId=parseInt($('#gameId').val()),
        id = parseInt($('#animationFunctionId option:selected').val()),
        timeout = parseInt($('#timeout').val()),
        ruleABC = [],
        len = parityCellGroups.length;
    if (id == 15) {
        for (let i=0;i<len;i++) {
            ruleABC[i] = parityCellGroups[i].getValueObjects();
        }
    }
    return {
        id:id,
        timeout:timeout,
        data:{
            gameId:gameId,
            objId:gameId,
            animationFunctionId:id,
            timeout:timeout,
            randomSeedValue:parseFloat($('#randomSeedValue').val())/100,
            fadeIn:parseInt($('#fadeIn').val()),
            fadeInColor:$('#fadeInColor').val(),
            fadeOut:parseInt($('#fadeOut').val()),
            fadeOutColor:$('#fadeOutColor').val(),
            fadeEnd:parseInt($('#fadeEnd').val()),
            fadeEndColor:$('#fadeEndColor').val(),
            persist:($('#persist').attr('checked') == undefined ? false : true),
            width:parseInt($('#cellsWide').val()),
            height:parseInt($('#cellsHigh').val()),
            cellWidth:parseFloat($('#cellWidth').val()),
            cellHeight:parseFloat($('#cellHeight').val()),
            ease:$('#ease option:selected').val(),
            cellRx:$('#cellRx').val(),
            cellRy:$('#cellRy').val(),
            ruleABC:ruleABC,
        }
    };
}

function gameInitWrap() {

    let formData = processGameOfLifeForm(),
        options  = formData.data,
        gameId   = options.objId;

    Games = [];
    GOLConfigs = [];
    GOLConfigs[gameId] = new GOLConfig(options)
    Games[gameId] = new gameOfLife(gameId,true);

    createGameBoard(gameId);
}

function gameInit() {

    let formData = processGameOfLifeForm(),
        options  = formData.data,
        gameId   = options.objId;

    Games = [];
    GOLConfigs = [];
    GOLConfigs[gameId] = new GOLConfig(options)
    Games[gameId] = new gameOfLife(gameId,false);

    createGameBoard(gameId);
}

</script>
</body>
</html>
