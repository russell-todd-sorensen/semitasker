<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" >

<title>LeetCode 30-Day Challenge: Day 15</title>
<!--
Maximum Sum Circular Subarray

Given a circular array C of integers represented by A, find 
the maximum possible sum of a non-empty subarray of C.

Here, a circular array means the end of the array connects 
to the beginning of the array.

(Formally, C[i] = A[i] when 0 <= i < A.length, 
and C[i+A.length] = C[i] when i >= 0.)

Also, a subarray may only include each element of the fixed 
buffer A at most once.  (Formally, for a subarray 
C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j 
with k1 % A.length = k2 % A.length.)


Example 1:

Input: [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3

Example 2:

Input: [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10

Example 3:

Input: [3,-1,2,-1]
Output: 4
Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4

Example 4:

Input: [3,-2,2,-3]
Output: 3
Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3

Example 5:

Input: [-2,-3,-1]
Output: -1
Explanation: Subarray [-1] has maximum sum -1

Note:

-30000 <= A[i] <= 30000
1 <= A.length <= 30000


One partial idea: reduce consecutive negative and positive numbers into one:
you dont need to keep track of the starting and ending of each group, since
the reduced group will have the same max subgroup

Also: the min-group + max-group = sum of entire list, so you could also fine
the min and reverse engineer the max.

-->
<script>
/**
 * @param {number[]} A
 * @return {number}
 */
var maxSubarraySumCircular = function(A) {
    let len = A.length,
        val = A[0],
        sum = val,
        sign = (val<0?-1:1),
        tsign = 0,
        total = sum,
        maxsum = 0,
        minsum = 0,
        minIdx = [],
        maxIdx = [],
        sumIdx = 0,
        C = [];

    for (let i=1;i<len;i++) {
        val = A[i];
        tsign = (val<0?-1:1)
        total += val;
        if (sign+tsign) {
            sum += val
        } else {
            C.push(sum);
            sumIdx = C.length-1;
            switch (sign) {
            case -1:
                if (sum == minsum) {
                    minIdx.push(sumIdx)
                }
                if (sum < minsum) {
                    minsum = sum;
                    minIdx = [sumIdx];
                }
                break;
            case 1: 
                if (sum == maxsum) {
                    maxIdx.push(sumIdx);
                }
                if (sum > maxsum) {
                    maxsum = sum;
                    maxIdx = [sumIdx];
                }
                break;
            }
            sum = val;
            sign = tsign;
        }
    }

    C.push(sum);
    sumIdx = C.length-1;
    switch (tsign) {
    case -1: 
        if (sum == minsum) {
            minIdx.push(sumIdx)
        }
        if (sum < minsum) {
            minsum = sum;
            minIdx = [sumIdx];
        }
        break;
    case 1: 
        if (sum == maxsum) {
            maxIdx.push(sumIdx);
        }
        if (sum > maxsum) {
            maxsum = sum;
            maxIdx = [sumIdx];
        }
        break;
    }

    let cLen = C.length,
        c0Sign = (C[0]<0?-1:1),
        cZSign = (C[cLen-1]<0?-1:1);
    if (cLen > 1) {
        switch (c0Sign+cZSign) {
        case -2:
        case  2: 
            C[0] += C[cLen-1];
            C.pop();
            cLen--;
        }
    }
    let stack = [];
    


    return {C:C,total:total,minsum:minsum,maxsum:maxsum,minIdx:minIdx,maxIdx:maxIdx};
};


</script>
</head>
<body>
<pre>
Maximum Sum Circular Subarray

Given a circular array C of integers represented by A, find 
the maximum possible sum of a non-empty subarray of C.

Here, a circular array means the end of the array connects 
to the beginning of the array.

(Formally, C[i] = A[i] when 0 &lt;= i &lt; A.length, 
and C[i+A.length] = C[i] when i &gt;= 0.)

Also, a subarray may only include each element of the fixed 
buffer A at most once.  (Formally, for a subarray 
C[i], C[i+1], ..., C[j], there does not exist i &lt;= k1, k2 &lt;= j 
with k1 % A.length = k2 % A.length.)


Example 1:

Input: [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3

Example 2:

Input: [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10

Example 3:

Input: [3,-1,2,-1]
Output: 4
Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4

Example 4:

Input: [3,-2,2,-3]
Output: 3
Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3

Example 5:

Input: [-2,-3,-1]
Output: -1
Explanation: Subarray [-1] has maximum sum -1

Note:

-30000 &lt;= A[i] &lt;= 30000
1 &lt;= A.length &lt;= 30000


One partial idea: reduce consecutive negative and positive numbers into one:
you dont need to keep track of the starting and ending of each group, since
the reduced group will have the same max subgroup

Also: the min-group + max-group = sum of entire list, so you could also fine
the min and reverse engineer the max.

</pre>
</body>
</html>


