<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" >

<title>LeetCode 30-Day Challenge: Day 18</title>
<!--

Minimum Path Sum

Given a m x n grid filled with non-negative numbers, find a path 
from top left to bottom right which minimizes the sum of all 
numbers along its path.

Note: You can only move either down or right at any point in 
time.

Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.

1 - 3 - 1
|   |   |
1 - 5 - 1
|   |   |
4 - 2 - 1

[[1,3,1],[1,5,1],[4,2,1]]

[
[1,2,3,4],
[3,4,7,2],
[1,6,2,1],
[2,3,1,3]
]


[[1,2,3,4],[3,4,7,2],[1,6,2,1],[2,3,1,3]]


[
[1,2,3,4,1],
[1,1,4,7,2],
[3,1,1,1,2],
[1,2,3,1,3],
[8,2,3,1,1]
]

[[1,2,3,4,1],[1,1,4,7,2],[3,1,1,1,2],[1,2,3,1,3],[8,2,3,1,1]]

-->
<script>
/**
 * @param {number[][]} grid
 * @return {number}


 Changed terminology to rows and cols
 */


var minPathSum = function(grid) {

    let cols = grid[0].length,
        rows = grid.length,
        maxCol = cols-1,
        maxRow = rows-1,
        paths = [],
        path,
        len,
        min = Infinity,
        minPath = [],
        col = 0,
        row = 0,
        oldPath,
        tmpLen;
        minPath[row] = [];
        minPath[row][col] = grid[row][col];

    paths.unshift([grid[row][col],[row,col]]);

    while (paths.length>0) {

        path  = paths.pop();
        len   = path[0];
        row   = path[1][0];
        col   = path[1][1];

        if (len > minPath[row][col]) {
            continue;
        }

        if (row<maxRow) {
            tmpLen = len + grid[row+1][col];
            while (true) {
                if (minPath[row+1] != undefined && minPath[row+1][col] != undefined) {
                    if (tmpLen >= minPath[row+1][col]) {
                        break;
                    } else {
                        oldPath = paths.shift()
                        if (!(oldPath[1][0] == row+1 && oldPath[1][1] == col)) {
                            paths.unshift(oldPath);
                        }
                    }
                }
                if (minPath[row+1] == undefined) {
                    minPath[row+1] = [];
                }
                minPath[row+1][col] = tmpLen;
                paths.unshift([tmpLen,[row+1,col]]);

                break;
            }
        }
        if (col<maxCol) {
            tmpLen = len+grid[row][col+1];
            while (true) {
                if (minPath[row] != undefined && minPath[row][col+1] != undefined) {
                    if (tmpLen >= minPath[row][col+1]) {
                        break;
                    }
                }
                if (minPath[row] == undefined) {
                    minPath[row] = [];
                }
                minPath[row][col+1] = tmpLen;
                paths.unshift([tmpLen,[row,col+1]]);

                break;
            }
        }
    }

    return minPath[maxRow][maxCol]
};
</script>
</head>
<body>
<pre>

</pre>
</body>
</html>


