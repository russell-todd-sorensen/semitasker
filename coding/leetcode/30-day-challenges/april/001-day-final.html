<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" >

<title>Radix Sort</title>
<style>
</style>

<!--
Problem is to find in O(n) time and constant space
one un-matched integer in list of integers.

Radix sort can be used as a starting point, which 
has O(kn) time. However, radix sort sorts the entire 
list, which isn't needed here. After each pass, the 
half with an even number of members is thrown away. 
This should take about a total of 2N operations.

The reasoning behind radix sorting is purely a trick of
the finite precision of integers, so it is an engineering
argument, not a mathematical one. Once you limit the size
of the inputs, the sorting cost is fixed. For an integer
size of 32 bits and memory the same size, you could only have
2^31-1 pairs of matched numbers, you couldn't even keep track
in one integer the number of operations required. The bottom line
is that the efficiency of the algo, although theoretical, is never
reached in practice.

The current problem might be better cast as bucket sort.
Looking at the lowest value binary digit, sort into bucket0
and bucket1, repeat with the bucket with odd number of members.

What about using log2(N) buckets
-->
<!-- Sorting into log2(N) buckets -->
<script>

var pickNumBuckets = function(len) {
    return (
        len<3?2
        :len==3?3
        :len<6?5
        :len<9?7
        :len<12?11
        :len<16?13
        :len<18?17
        :len<21?19
        :len<26?23
        :len<30?29
        :31
    )
}

var singleNumber = function (arr) {

    let len = arr.length,
        numBuckets = (
            len<3?2
            :len==3?3
            :len<6?5
            :len<9?7
            :len<12?11
            :len<16?13
            :len<18?17
            :len<21?19
            :len<26?23
            :len<30?29
            :31),
        buckets = new Array(),
        n = 0,
        found = false,
        k=0, // estimated time complexity = N*1.1 = O(N)
        total = 0,
        loopBreak = 0,
        maxLoop = 3*len,
        answer = null,
        val,
        bucket;

    while (!found) {
        k += len;
        if (numBuckets > 2) {
            while (arr.length > 0) {
                bucket = arr[0]%numBuckets
                if (buckets[bucket]) {
                    buckets[bucket].push(arr.shift()); // reuse memory
                } else {
                    buckets[bucket] = [arr.shift()];
                }
            }
        } else {
            while (arr.length > 0) {
                bucket = ((arr[0] & 1<<n)==0)?0:1;
                if (buckets[bucket]) {
                    buckets[bucket].push(arr.shift()); // reuse memory
                } else {
                    buckets[bucket] = [arr.shift()];
                }
            }
        }
        for (let j in buckets) {
            k++;
            if ((buckets[j].length%2) == 1) {
                arr = buckets[j]
                len = arr.length
                numBuckets--;
                if (numBuckets == 16 
                    || numBuckets == 8) 
                {
                    numBuckets--;
                }
                if (numBuckets <2) {
                    numBuckets = 2;
                }
                buckets = new Array();
                break;
            }
        }
        if (arr.length == 1) {
            answer = arr[0]
            found = true;
            break;
        }
        n++
    }

    return answer
}

</script>
</head>
<body>
<pre>

</pre>
</body>
</html>
