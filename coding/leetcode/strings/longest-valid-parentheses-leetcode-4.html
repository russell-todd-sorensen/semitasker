<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" >

<title>Longest Valid Parentheses</title>
<style>
</style>
<script src="/js/jquery-3.1.1.js"></script>

<script>
/* from: https://leetcode.com/problems/longest-valid-parentheses/
Given a string containing just the characters '(' and ')', find
 the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
Example 2:

Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"

*/

/**
 * @param {string} s
 * @return {number}
 */

class Candidate {
    startIndex;
    endIndex;
    balance;
    maxValid = 0;
    constructor(start) {
        this.startIndex = start;
        this.balance = 1;
        return this;
    }
    openP (current) {
        this.balance++;
        return this.balance;
    }
    closeP (current) {
        this.balance--;
        if (this.balance == 0) {
            this.maxValid = current - this.startIndex + 1;
            this.endIndex = current;
        }
        return this.balance;
    }
}

var candidateList = [];

var longestValidParentheses = function(s) {

    candidateList = [];
    let longest = 1, // this is an impossible length
        v,
        cand,
        max = 0,
        len = 0,
        maxLength = 0,
        total = 0,
        count = 0,
        averageLength = 0;

    for (let i=0,vi=0;i<s.length;i++,vi++) {
        v = s[i]
        len = candidateList.length;
        if (len > maxLength) {
            maxLength = len;
        }
        total += len;
        count++;
        switch (v) {
        case "(":
            for (let j=0;j<candidateList.length;j++) {
                candidateList[j].openP(vi);
            }
            candidateList.unshift(new Candidate(vi))
            break;
        case ")":
            if (candidateList.length == 0) {
                break;
            }
            for (let j=0;j<candidateList.length;j++) {
                cand = candidateList[j]
                cand.closeP(vi);
                if (cand.balance == 0) {
                    max = cand.maxValid;
                    if (max > longest) {
                        longest = max
                    }
                } else
                if (cand.balance == -1) {
                    candidateList.shift();
                    j--
                }
            }
            break;
        default: 
            vi--;
            break;
        }
    }
    longest = (longest < 2 ? 0 : longest);
    count = (count == 0 ? 1 : count);
    return {longest: longest, strLen:s.length,maxStack: maxLength, total:total, averageStack:total/count}
};


var testCases = [
    {val: "", len: 0},
    {val: " ", len: 0},
    {val: "() ", len: 2},
    {val: ")", len: 0},
    {val: "(", len: 0},
    {val: "()", len: 2},
    {val: ")))((()", len: 2},
    {val: "()()", len: 4},
    {val: "(()())", len: 6},
    {val: "()()()))((", len: 6},
    {val: ")))((()))", len: 6},
    {val: "())()())))()()()()", len: 8},
    {val: "())()())))(()()()()", len: 8},
    {val: "((((()))))", len: 10},
    {val: "(()(()())((())()(())", len: 10},
    {val: "()()()()())", len: 10},
    {val: "()()()()(()))", len: 12},
    {val: "()()()()(()))(()(()())((())()(())", len: 12},
    {val: "))(((((())()())(()))())()))())))))", len: 24},
    {val: "((((((((()(())(())(((()))))))))()))))", len: 36},
    {val: "((((((((((()(())(())(((()))))))))()))))", len: 38},
    {val: ")())(()))((())))(((()))))((((())))))(((((()))))))(", len: 12},
    //{val: , len: },
    //{val: , len: },
    //{val: , len: },
   /// {val: , len: },

];

testCases = [];


var testAll = function(testArray) {
    let input,
        result,
        target;
    for (let i=0;i<testArray.length;i++) {
        input = testArray[i];
        target = input.len;
        let result = longestValidParentheses(input.val);
        if (result == target) {
            console.log(`PASS max of '${input.val}' = '${result}'`);
        } else {
            console.log(`FAIL max of '${input.val}' = '${result}' should be '${target}'`);
        }
    }
}


let generateRandomParen = function (n,beginSequence) {

    let fullSequence = (beginSequence ? beginSequence : "");

    for (let i=beginSequence.length;i<n;i++) {
        if (Math.random() < 0.5) {
            if (i%2 == 0) {
                fullSequence += "(";
            } else {
                fullSequence = "(" + fullSequence;
            }
        } else {
            if (i%2 == 0) {
                fullSequence += ")";
            } else {
                fullSequence = ")" + fullSequence;
            }
        }
    }
    return fullSequence;
}

testAll = function(maxCount,minLength, maxLength) {

    let testsPerLength = Math.trunc(maxCount/(maxLength-minLength));
    testsPerLength = testsPerLength < 1 ? 1 : testsPerLength;
    let testVal = "",
        startTestVal = "",
        result = 0,
        ro;
    let preHandle = $('#output'),
        max = 0;
        testCases = [];
        preHandle.html("");

    for (let i=minLength;i<=maxLength;i++) {
        for (let j=0;j<testsPerLength;j++) {
            testVal = generateRandomParen(i,startTestVal);
            ro = longestValidParentheses(testVal)
            result=ro.longest;
            testCases.push({val:testVal,len:result});
            preHandle.append(`{val: \"${testVal}\",strLen:${ro.strLen}, len:${result}, maxStack: ${ro.maxStack}, averageStack:${ro.averageStack},totalStack:${ro.total}}\n`)
        }
        startTestVal = testVal;
        startTestVal = ""
    }
}


</script>
</head>
<body>
<pre id="output">

</pre>
</body>
</html>


