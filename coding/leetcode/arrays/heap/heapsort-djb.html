<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" >

<title>HeapSort</title>
<style>
</style>

<script src="/js/d3.v3.js"></script>

<script>
    /*
struct heap_entry {
  int apos;
  int32 b;
  int64 sum;
} ;
*/


class HeapEntry {
    constructor (apos, b, sum) {
        this.apos = (apos?apos:0);
        this.b = (b?b:0);
        this.sum = (sum?sum:0);
        return this;
    }
}

class Heap {
    heap = [];
    entries = 0;
    ops = 0; // for counting O()
    history = [];
    failedAt = -1; // result of verify();
    constructor () {
        this.heap[0] = new HeapEntry(0,0,0);
        return this;
    }
    add (entry,pos) {
        let entryPos = (pos?pos:this.heap.length)
        this.heap[entryPos] = entry;
        if (entryPos > 0) {
            this.entries++
        }
        return entryPos;
    }
    add0 (entry) {
        this.heap[0] = entry;
    }
    get (pos) {
        if (pos && pos < 0) {
            return null;
        }
        let entryPos = (pos?pos:0)
        if (entryPos < this.heap.length) {
            return this.heap[entryPos]
        } else {
            return null;
        }
    }
    getEntries () {
        return this.entries;
    }
    /* insert h[0], delete h[j] 

    static inline void heap_permute(struct heap_entry *h,int j,int n)
    {
    int p;
    int q;

    q = j;

    while ((p = q << 1) < n) {
        if (h[p + 1].sum < h[p].sum) ++p;
        h[q] = h[p]; q = p;
    }
    if (p == n) {
        h[q] = h[p]; q = p;
    }
    while ((q > j) && (h[0].sum < h[p = q >> 1].sum)) {
        h[q] = h[p]; q = p;
    }
    h[q] = h[0];
    }
    */
    permute (j,n) {

        this.history[this.history.length] = this.heap;

        let q;
        var p;

        q = j;

        p = q<<1;

        while (p < n) {
            this.ops++;
            if (this.heap[p + 1].sum < this.heap[p].sum) {
                ++p;
            }
            this.heap[q] = this.heap[p]
            q = p
            p = q<<1
        }
        if (p == n) {
            this.ops++;
            this.heap[q] = this.heap[p]
            q = p;
        }
        p = q>>1
        while ((q > j) && (this.ops++) && (this.heap[0].sum < this.heap[p].sum)) { 
            this.heap[q] = this.heap[p];
            q = p;
            p = q>>1
        }
        this.ops++;
        this.heap[q] = this.heap[0];
    }    
    permuteZ (j,n,z) {

        this.history[this.history.length] = this.heap;

        let q;
        var p;

        q = j;

        p = q<<1;

        while (p < n) {
            this.ops++;
            if (this.heap[p + 1].sum < this.heap[p].sum) {
                ++p;
            }
            this.heap[q] = this.heap[p]
            q = p
            p = q<<1
        }
        if (p == n) {
            this.ops++;
            this.heap[q] = this.heap[p]
            q = p;
        }
        p = q>>1
        while ((q > j) && (this.ops++) && (this.heap[z].sum < this.heap[p].sum)) { 
            this.heap[q] = this.heap[p];
            q = p;
            p = q>>1
        }
        this.ops++;
        this.heap[q] = this.heap[z];
    }
    init(jOver) {
        let n = this.getEntries();
        let j = Math.floor(n / 2) + 1;
        j = (jOver?jOver:j)
        while (j > 1) {
            --j;
            this.add0(this.peek(j))
            this.permuteZ(j,n,0)
        }
    }
    verify() {
        let n = this.getEntries();
        this.failedAt = [];
        let max = Math.floor(n/2);
        let i = 1;
        let pass = true;
        let val;
        while (i<=max) {
            val = this.peek(i).sum
            if (val > this.peek(i*2).sum) {
                this.failedAt.push({i:i,k:2*i})
                pass = false;
            }
            if ((i*2+1)<=n && val > this.peek(i*2+1).sum) {
                this.failedAt.push({i:i,k:2*i+1})
                pass = false
            }
            i++
        }
        return pass
    }
    push(entry) { // remove the 0th element and push on two copies
        //for (let i = this.entries; i > 0;i--) {
            //this.heap[i+1] = this.heap[i]
       // }
        this.heap.shift()
        //this.add(entry,1);
        //this.add0(entry);
        this.heap.unshift(entry);
        this.heap.unshift(entry);
        this.entries++;
        //this.permute(1,this.entries);
        //this.ops++;
        return this.heap;
    }
    peek(pos) {
        if (pos && pos<=this.entries) {
            return this.heap[pos]
        } else {
            return null;
        }
    }
    pop() {
        if (this.entries == 0) {
            return null;
        }
        let tmp = this.heap[1]
        this.heap[0] = this.heap[this.entries]
        this.heap[this.entries] = null;
        this.heap.pop(); //removed the unused element
        this.entries--
        if (this.entries > 0) {
            this.permute(1,this.entries)
        }
        return tmp;
    }
    sort() {
        let len = 0 + this.entries;
        for (let i = 0;i<len;i++) {
            let tmp = this.heap[1]
            this.heap[0] = this.heap[this.entries]
            this.permute(1,this.entries)
            this.heap[this.entries] = tmp;
            this.entries--
        }
    }
    getOps() {
        return this.ops;
    }
    resetOps() {
        let ops = this.ops;
        this.ops = 0;
        return ops;
    }
}

var h

var snapshot = [];
var failedAt = [];
var ordered  = [];

function pushRandom(heap,n,min,max) {
    let h = heap;
    for (let i = 0;i<n;i++) {
        val = Math.ceil((Math.random()*(max-min))+min)
        h.push(new HeapEntry(i,('b' + i), val))
    }
}

function testHeapSort(n,min,max,verifyEachStep,exitOnFailure) {

    h = new Heap();
    let val;
    let verified = true;
    snapshot = [];
    ordered  = [];

    for (let i = 0;i<n;i++) {
        val = Math.ceil((Math.random()*(max-min))+min)
        h.push(new HeapEntry(i,('b' + i), val))
        snapshot[snapshot.length] = h.heap.map(x => (x==null?0:x.sum))
        if (verifyEachStep) {
            verified = h.verify();
        }
        if (exitOnFailure && h.failedAt.length > 0) {
            return 
        }
    }

    console.log('Added n=' 
        + n + ', ops=' 
        + h.getOps() 
        + ', n*log2(n)=' 
        + (n * (Math.ceil(1000*Math.log2(n))/1000)));
    if (!verifyEachStep) {
        verified = h.verify();
    }

    if (!verified) {
        let failedNodes = "";
        let failedNode;
        for (let i=0;i<h.failedAt.length;i++) {
            failedNode = h.failedAt[i]
            failedNodes = failedNodes + "i="
            + failedNode.i + ", val="
            + h.get(failedNode.i).sum + ", k="
            + failedNode.k + ", val="
            + h.get(failedNode.k).sum + "; "
        }
        console.log("heap =[" + h.heap.map(x => (x==null?0:x.sum)).toString() + "]")
        console.log("Failed verification at " + failedNodes + " running init()")
        h.init();
    }

    verified = h.verify();

    if (!verified) {
        console.log("failed second verification at " + h.failedAt + " quitting.")
        return;
    }

    while (verified && h.getEntries() > 0) {
        snapshot[snapshot.length] = h.heap.map(x => (x==null?0:x.sum))
        ordered[ordered.length] = h.pop().sum
    }

    snapshot[snapshot.length] = h.heap.map(x => (x==null?0:x.sum))

    console.log('Added and Removed n=' 
        + n + ', ops=' 
        + h.getOps() 
        + ', 2*n*log2(n)=' 
        + (2 * n * Math.ceil(1000*Math.log2(n))/1000));

    console.log('[' + ordered.toString() + ']');

    let i = 0;
    let passed = true;
    let blurb = ""
    while (i < (n-1)) {
        if (ordered[i] > ordered[i+1]) {
            passed = false
            blurb = "ordered["+i+"]=''" + ordered[i] + "'' and ordered[" + (i+1) + "]=''" + ordered[i+1] + "'"
            break
        }
        i++
    }
    console.log("Popped values: " + passed + " " + blurb);
}

var arr2 = [10, 23, 13, 31, 62, 30, 33, 116, 89, 107, 54, 111, 200, 135, 140, 132, 144, 133, 144, 177];
var arrt = [111,111,19,40,40,46,41,118,48,120,46,63,120,170,198,76,140,151,194]

function makeHeap (arr) {
    var h = new Heap();
    h.heap = []
    for (let i = 0;i<arr.length;i++) {
        h.heap.push(new HeapEntry(i,i,arr[i]));
        h.entries++
    }
    h.entries--
    return h
}

var arr3 = [66,93,72,76,5,81,44,19,63,3,89,10,65,46,100,39,86,81,54,16]
var h3 = new Heap();

function addEntries (h,arr) {
    let test = 0;
    for (let i = 0;i<arr.length;i++) {
        h.push(new HeapEntry(i,'b'+i,arr[i]))
        test = i;
    }
    return h
}
function sumLogN(n) {
    let total = 0;
    for (let i=n;i>0;i--) {
        total += Math.log2(i)
    }
    return total;
}



var testHeapArray = [18,12,11,10,6,16,5,9,1,7,2,3,4,8,5]
var demoArray = [{apos:1,b:"b1",sum:5},
{apos:1,b:"b1",sum:5},
{apos:2,b:"b2",sum:8},
{apos:3,b:"b3",sum:4},
{apos:4,b:"b4",sum:3},
{apos:5,b:"b5",sum:15},
{apos:6,b:"b6",sum:7},
{apos:7,b:"b7",sum:1},
{apos:8,b:"b8",sum:2},
{apos:9,b:"b9",sum:13},
{apos:10,b:"b10",sum:12},
{apos:11,b:"b11",sum:6},
{apos:12,b:"b12",sum:10},
{apos:13,b:"b13",sum:11},
{apos:14,b:"b14",sum:9},
{apos:15,b:"b15",sum:14}
]

h3.heap = demoArray
h3.entries = 15;
var cellsPerRow = 1
var currentCol = 1
var graph_config = {
    heap: h3,
    id: "heap",
    svgId: "svg1",
    scale: 1.0,
    height: 1500,
    width: 1000,
    margin: 5,
    cellWidth: 40,
    cellHeight: 40,
    fontSize: 20,
    valueField: "sum",

}

var showHeap = function(config) {
    let myHeap = config.heap;
    let svgHeap = d3.select("#" + config.svgId);
    let len = myHeap.getEntries();
    let cellWidth = config.cellWidth;

    let data = myHeap.heap;
    svgHeap
        .selectAll('rect')
        .data(data)
        .enter()
        .append("rect")
        .attr("x",function(d,i) {
            if (i < 2) {
                return 500-20
                cellsPerRow = 1
                currentCol = 1
            } else {
                cellsPerRow *= 2
                let row  = Math.floor(Math.log2(i))
                cellsPerRow = Math.pow(2,(row-1))
                let gaps = cellsPerRow+1;
                let gap = 1000/gaps;
                //let rows = Math.log2(data.length-1)
                return Math.round((gap)*(currentCol++));
            }
        })
        .attr("y",function(d,i) {
            if (i == 0) {
                return 10
            } else {
                let rows = Math.log2(data.length-1)
                let row  = Math.floor(Math.log2(i))
                return (10 + (row + 1) * 80) 
            }
        });
        svgHeap
        .selectAll('text')
        .data(data)
        .enter()     
        .append("text")
        .attr("x",function(d,i) {
            if (i < 2) {
                return 500
                cellsPerRow = 1
                currentCol = 1
            } else {
                let row  = Math.floor(Math.log2(i))
                cellsPerRow  = Math.pow(2,(row-1))
                let gaps = cellsPerRow+1;
                let gap = 1000/gaps;
                //let rows = Math.log2(data.length-1)
                return Math.round((gap)*(currentCol++));
            }
        })
        .attr("y",function(d,i) {
            if (i == 0) {
                return 45
            } else {
                let rows = Math.log2(data.length-1)
                let row  = Math.floor(Math.log2(i))
                return ( (row +1) * 80) + 45
            }
        })
        .text(function(d,i) {
            return d.sum
        });

}

</script>

</head>
<body>
<pre>
This is a test.
</pre>
<svg 
    id="svg1"    
    xmlns:svg="http://www.w3.org/2000/svg"
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xml:base="https://home.semitasker.com/"
    externalResourcesRequired="true"
    height="2000"
    width="1000"
    >
<style>
rect {
    height: 40px;
    width: 40px;
    stroke: yellow;
    stroke-width: 3px;
    opacity: .3;
}
text {
    stroke: none;
    fill: black;
    font-size: 20px;
    text-anchor: middle;
}
</style>
<defs>

</defs>

<g id="heap"></g>

</svg>
</body>
</html>


