<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8" >

<title></title>
<script src=""></script>

<script>


var ListNode = function(val) {
    this.val = val;
    this.next = null;
};

ListNode.prototype.append = function (val) {
    if (this.next) {
        this.next.append(val);
    } else {
        this.next = new ListNode(val);
    }
};

ListNode.prototype.toString = function () {
    if (this.next) {
        return "" + this.val + "->" + this.next.toString();
    } else {
        return "" + this.val;
    }
};

ListNode.prototype.stashArray = function (a) {
    a[a.length] = this
    if (this.next) {
        a = this.next.stashArray(a)
    }
    return a
}

var reverseFirstKList = function(head,k) {
    var a = new Array(k+1)
    a[0] = head
    for (var i = 1;i<=k;i++) {
        a[i] = head.next;
        head = head.next
    }
    
    for (i--;i>1;i--) {
        a[i-1].next = a[i-2]
    }
    a[0].next = a[k]
    return a[k-1]
}

reverseKGroupOne = function (head, k) {

    var S = head
    var T = S.next
    var U = T.next
    var i = k-1;
    while (head.next && (i > 0)) {
        head = head.next
        i--;
        console.log("stepping val=" + head.val)
    }
    if (i == 0) {
        S.next = head.next
        for (var j=0;j<k-1;j++) {
            U = T.next
            T.next = S
            S = T
            T = U
        }
        return head
    } else {
        return S
    }
}

reverseKGroup = function (head, k) {

var S = null,T,U,V,i,nextHead,newHead = null;

    while (head) {
        S = head
        T = S.next
        if (!T) {
            break
        }
        i = k-1;
        while (head.next && (i > 0)) {
            head = head.next
            i--;
        }
        if (i == 0) {
            if (!newHead) {
                newHead = head;
            }
            if (V) {
                V.next = head;
            }
            V = S
            S.next = head.next
            nextHead = head.next
            for (var j=0;j<k-1;j++) {
                U = T.next
                T.next = S
                S = T
                T = U
            }
            if (!nextHead) {
                break
            }
            head = nextHead
        } else {
            break
        }
    }
    if (!newHead) {
        return S 
    } else {
        return newHead
    }
}

var listA = {val:1, next:{val:2, next:{val:3, next:{val:4, next:{val:5,next:null}}}}}
var listB = new ListNode(1)
listB.append(2)
listB.append(3)
listB.append(4)
listB.append(5)
listB.append(6)
listB.append(7)

var listC = new ListNode(1)
listC.append(2);

var result = "none yet"
console.log ("result = " + result)


</script>
</head>
<body>
<pre>
    /*
        25. Reverse Nodes in k-Group
        Hard
        
        1372
        
        276
        
        Favorite
        
        Share
        Given a linked list, reverse the nodes of a
        linked list k at a time and return its modified list.
        
        k is a positive integer and is less than or equal to the length
        of the linked list. 
        
        If the number of nodes is not a multiple of k
        then left-out nodes in the end should remain as it is.
        
        Example:
        
        Given this linked list: 1->2->3->4->5
        
        For k = 2, you should return: 2->1->4->3->5
        
        For k = 3, you should return: 3->2->1->4->5
        
        Note:
        
        Only constant extra memory is allowed.
        You may not alter the values in the list's nodes,
        only nodes itself may be changed.
 
 
 
        */
        /**
         * Definition for singly-linked list.
         * function ListNode(val) {
         *     this.val = val;
         *     this.next = null;
         * }
         */
        /**
         * @param {ListNode} head
         * @param {number} k
         * @return {ListNode}
         */
</pre>
</body>
</html>
