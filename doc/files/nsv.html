<html><head>
<title>nsv - NaviServer Built-in Commands </title>
<link rel="stylesheet" href=".././nsd.css" type="text/css">
</head>
<! -- Generated from file 'files/nsv.html' by tcllib/doctools with format 'html'
   -->
<! -- CVS: $Id$ nsv.n
   -->

<body>
<hr> [
  <a href=".././toc.html">Table Of Contents</a>
| <a href=".././index.html">Keyword Index</a>
] <hr>

<h1> nsv(n) 4.99  &quot;NaviServer Built-in Commands&quot;</h1>
<h2><a name="name">NAME</a></h2>
<p>
<p> nsv - NaviServer nsv Commands




<h2><a name="table_of_contents">TABLE OF CONTENTS</a></h2>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#table_of_contents">TABLE OF CONTENTS</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#synopsis">SYNOPSIS</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#description">DESCRIPTION</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#commands">COMMANDS</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#migrating_from_ns_share">Migrating From ns_share</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#multithreading_features">Multithreading Features</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#compatibility_with_tcl_arrays">Compatibility with Tcl Arrays</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#configuration">Configuration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#see_also">SEE ALSO</a><br>
<h2><a name="synopsis">SYNOPSIS</a></h2>
<p>
<table border=1 width=100% cellspacing=0 cellpadding=0><tr            bgcolor=lightyellow><td bgcolor=lightyellow><table 0 width=100% cellspacing=0 cellpadding=0><tr valign=top ><td ><a href="#1"><b class='cmd'>nsv_array</b> <i class='arg'>get</i> <i class='arg'>array</i> ?<i class='arg'>pattern</i>?</a></td></tr>
<tr valign=top ><td ><a href="#2"><b class='cmd'>nsv_array</b> <i class='arg'>set</i> <i class='arg'>array</i> <i class='arg'>value-list</i></a></td></tr>
<tr valign=top ><td ><a href="#3"><b class='cmd'>nsv_array</b> <i class='arg'>reset</i> <i class='arg'>array</i> <i class='arg'>value-list</i></a></td></tr>
<tr valign=top ><td ><a href="#4"><b class='cmd'>nsv_array</b> <i class='arg'>exists</i> <i class='arg'>array</i></a></td></tr>
<tr valign=top ><td ><a href="#5"><b class='cmd'>nsv_array</b> <i class='arg'>size</i> <i class='arg'>array</i></a></td></tr>
<tr valign=top ><td ><a href="#6"><b class='cmd'>nsv_array</b> <i class='arg'>names</i> <i class='arg'>array</i> ?<i class='arg'>pattern</i>?</a></td></tr>
<tr valign=top ><td ><a href="#7"><b class='cmd'>nsv_exists</b> <i class='arg'>array</i> <i class='arg'>key</i></a></td></tr>
<tr valign=top ><td ><a href="#8"><b class='cmd'>nsv_get</b> <i class='arg'>array</i> <i class='arg'>key</i></a></td></tr>
<tr valign=top ><td ><a href="#9"><b class='cmd'>nsv_incr</b> <i class='arg'>arrayName</i> <i class='arg'>key</i> ?<i class='arg'>increment</i>?</a></td></tr>
<tr valign=top ><td ><a href="#10"><b class='cmd'>nsv_append</b> <i class='arg'>array</i> <i class='arg'>key</i> <i class='arg'>value</i> ?<i class='arg'>value ...</i>?</a></td></tr>
<tr valign=top ><td ><a href="#11"><b class='cmd'>nsv_lappend</b> <i class='arg'>array</i> <i class='arg'>key</i> <i class='arg'>value</i> ?<i class='arg'>value ...</i>?</a></td></tr>
<tr valign=top ><td ><a href="#12"><b class='cmd'>nsv_names</b> ?<i class='arg'>pattern</i>?</a></td></tr>
<tr valign=top ><td ><a href="#13"><b class='cmd'>nsv_set</b> <i class='arg'>array</i> <i class='arg'>key</i> <i class='arg'>value</i></a></td></tr>
<tr valign=top ><td ><a href="#14"><b class='cmd'>nsv_unset</b> <i class='arg'>array</i> ?<i class='arg'>key</i>?</a></td></tr>
</table></td></tr></table>
<h2><a name="description">DESCRIPTION</a></h2>
<p>
The nsv commands provide a high performance data sharing mechanism.
This facility is much flexible alternative to the obsolete ns_share
command.  The model uses an array syntax and includes more features.
In addition, lock contention is managed in a much more scalable
way--something that is not possible with the obsolete ns_share
facility.


<h2><a name="commands">COMMANDS</a></h2>
<p>

<dl>


<dt><a name="1"><b class='cmd'>nsv_array</b> <i class='arg'>get</i> <i class='arg'>array</i> ?<i class='arg'>pattern</i>?</a><dd>


<dt><a name="2"><b class='cmd'>nsv_array</b> <i class='arg'>set</i> <i class='arg'>array</i> <i class='arg'>value-list</i></a><dd>


<dt><a name="3"><b class='cmd'>nsv_array</b> <i class='arg'>reset</i> <i class='arg'>array</i> <i class='arg'>value-list</i></a><dd>


<dt><a name="4"><b class='cmd'>nsv_array</b> <i class='arg'>exists</i> <i class='arg'>array</i></a><dd>


<dt><a name="5"><b class='cmd'>nsv_array</b> <i class='arg'>size</i> <i class='arg'>array</i></a><dd>


<dt><a name="6"><b class='cmd'>nsv_array</b> <i class='arg'>names</i> <i class='arg'>array</i> ?<i class='arg'>pattern</i>?</a><dd>


Commands for the most part mirror the cooresponding Tcl command for
ordinary variables.


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
   % nsv_array set shared_array { key1 value1 key2 value2 }

   % nsv_array get shared_array
   key1 value1 key2 value2
   % nsv_array reset shared_array { key3 value3 }
   % nsv_array exists shared_array
   1
   % nsv_array size shared_array
   1
   % nsv_array names shared_array
   key3
   % nsv_array set shared_array [array get tmp_shared_array]
   % array set tmp_shared_array [nsv_array get shared_array]
   % nsv_array reset shared_array [array get tmp_shared_array]
</pre></td></tr></table></p>


<br><br>
<dt><a name="7"><b class='cmd'>nsv_exists</b> <i class='arg'>array</i> <i class='arg'>key</i></a><dd>


Test whether a key exists in the nsv array.

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
   % nsv_exists shared_array key1
   1
   % nsv_exists shared_array key2
   0
</pre></td></tr></table></p>


<br><br>
<dt><a name="8"><b class='cmd'>nsv_get</b> <i class='arg'>array</i> <i class='arg'>key</i></a><dd>



Get the value for the key from the nsv array.  Error occurs if key does not exist.

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
   % nsv_get shared_array key1
   value1
</pre></td></tr></table></p>


<br><br>
<dt><a name="9"><b class='cmd'>nsv_incr</b> <i class='arg'>arrayName</i> <i class='arg'>key</i> ?<i class='arg'>increment</i>?</a><dd>



If increment is supplied then its value (which must be an integer) is added to the
value of the element key; otherwise 1 is added to the value of the element key.
Unlike the TCL equivalent if key does not exists it is created. Returns the new value
of the element specified by key. Internally interlocked so it is thread safe, no mutex required.


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
   % nsv_incr shared_array foo
   1
   % nsv_incr shared_array foo -1
   0
</pre></td></tr></table></p>

<br><br>
<dt><a name="10"><b class='cmd'>nsv_append</b> <i class='arg'>array</i> <i class='arg'>key</i> <i class='arg'>value</i> ?<i class='arg'>value ...</i>?</a><dd>


Append all of the value arguments to the current value of variable key in the array.
If key doesn't exist, it is given a value equal to the concatenation of all the value arguments

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
   % nsv_append shared_array key1 foo
   value1foo
</pre></td></tr></table></p>


<br><br>
<dt><a name="11"><b class='cmd'>nsv_lappend</b> <i class='arg'>array</i> <i class='arg'>key</i> <i class='arg'>value</i> ?<i class='arg'>value ...</i>?</a><dd>



Append all of the value arguments as list elements to variable key in the array.
If key doesn't exist, it is created as a list with elements given by the value arguments


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
   % nsv_lappend shared_array key1 value2
   value1 value2
</pre></td></tr></table></p>


<br><br>
<dt><a name="12"><b class='cmd'>nsv_names</b> ?<i class='arg'>pattern</i>?</a><dd>


Return a list of all the nsvs in use, optionally only those matching pattern. If no
matching nsvs are in use returns the empty string.

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
   % nsv_names
   shared_array
</pre></td></tr></table></p>


<br><br>
<dt><a name="13"><b class='cmd'>nsv_set</b> <i class='arg'>array</i> <i class='arg'>key</i> <i class='arg'>value</i></a><dd>



Set the value for a key in an nsv array. Returns the value the key is set to.

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
   % nsv_set shared_array key1 value1
   value1
</pre></td></tr></table></p>


<br><br>
<dt><a name="14"><b class='cmd'>nsv_unset</b> <i class='arg'>array</i> ?<i class='arg'>key</i>?</a><dd>


Unset an array or a single key from an array. If successful returns an empty string.

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
   % nsv_unset shared_array key1
   %nsv_unset shared_array
</pre></td></tr></table></p>


</dl>

<h2><a name="migrating_from_ns_share">Migrating From ns_share</a></h2>
<p>

Migrating from ns_share is straightforward.  If your init.tcl included commands such as:

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
	ns_share myshare
	set myshare(lock) [ns_mutex create]

</pre></td></tr></table></p>

use instead:

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>

	nsv_set myshare lock [ns_mutex create]

</pre></td></tr></table></p>


In your procedures, instead of:

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>

	proc myproc {} {
		ns_share myshare
		ns_mutex lock $myshare(lock)
		...


</pre></td></tr></table></p>

use:

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>

	proc myproc {} {
		ns_mutex lock [nsv_get myshare lock]
		...


</pre></td></tr></table></p>

and within an ADP page, instead of:


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
	&lt;%
	ns_share myshare
	ns_puts $myshare(key1)
	%&gt;

	&lt;%=$myshare(key2)%&gt;


</pre></td></tr></table></p>

use:


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
	&lt;%
	ns_puts [nsv_get myshare key1]
	%&gt;

	&lt;%=[nsv_get myshare key2]%&gt;


</pre></td></tr></table></p>

Notice that, unlike ns_share, no command is required to define the
shared array.  The first attempt at setting the variable through any
means will automaticaly create the array.  Also notice that only arrays
are supported.  However, to migrate from ns_share you can simply package
up all existing ns_share scalars into a single array with a short name,
perhaps just &quot;.&quot;. For example, if you had:


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
	ns_share mylock myfile
	set myfile /tmp/some.file
	set mylock [ns_mutex create]

</pre></td></tr></table></p>


you can use:

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>

	nsv_set . myfile /tmp/some.file
	nsv_set . mylock [ns_mutex create]


</pre></td></tr></table></p>


<h2><a name="multithreading_features">Multithreading Features</a></h2>
<p>

One advantages of nsv is built in interlocking for thread safety.
For example, consider a case of a &quot;increment-by-one&quot; unique id system.
Here's the ns_share solution:


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>
	ns_share ids
	set ids(lock) [ns_mutex create]
	set ids(next) 0

	proc nextid {} {
		ns_share ids
		ns_mutex lock $ids(lock)
		set next [incr ids(next)]
		ns_mutex unlock $ids(lock)
		return $next
	}


</pre></td></tr></table></p>


and here's an nsv solution:


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>

	nsv_set ids next 0

	proc nextid {} {
		return [nsv_incr ids next]
	}


</pre></td></tr></table></p>


Note that the nsv solution does not need a mutex as the nsv_incr command
is internally interlocked.


<h2><a name="compatibility_with_tcl_arrays">Compatibility with Tcl Arrays</a></h2>
<p>

Another useful feature of nsv is the nsv_array command which works much
like the Tcl array command.  This can be used to import and export values
from ordinary Tcl arrays.  For example, to copy from Tcl use:


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>

	nsv_array set meta [array get tmpmeta]

</pre></td></tr></table></p>


and to copy to Tcl use:

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>


	array set metacopy [nsv_array get meta]


</pre></td></tr></table></p>


As with all other nsv command, nsv_array is atomic and no explicit
locking is required.  This feature can be used to contruct a new nsv
array by first filling up an ordinary temporary Tcl array via some time
consuming process and then swapping it into place as above.  While the
new temporary array is being constructed, other threads can access the
old array without delay or inconsistant data.  You can even reset a
complete nsv array in one step with &quot;reset&quot;.  For example, instead of:


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>

	ns_share lock meta
	set lock [ns_mutex create]
	ns_mutex lock $lock
	unset meta
	array set meta [array get tmpmeta]
	ns_mutex unlock $lock

</pre></td></tr></table></p>


you can simply use:


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>


	nsv_array reset meta [array get tmpmeta]


</pre></td></tr></table></p>


The reset option will flush and then reset all values atomically,
eliminating the need for the explicit lock.


<h2><a name="configuration">Configuration</a></h2>
<p>


The nsv system uses a common multithreading technique to reduce the
potential for lock contention which is to split the locks to acheive
finer grained locking.  This technique groups arrays randomly into
buckets and only the arrays within a particular bucket share a lock.
The number of buckets to be used can be configured by setting the
&quot;nsvbuckets&quot; tcl parameters, e.g.:

<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>


	[ns/server/server1/tcl]
        nsvbuckets=20

</pre></td></tr></table></p>


The default is 8 which should be reasonalbe.  Note that you can monitor
the lock contention, if any, by enabling mutex metering:


<p><table><tr><td bgcolor=black>&nbsp;</td><td><pre class='sample'>

	[ns/threads]
        mutexmetering=on

</pre></td></tr></table></p>

and then viewing the results of &quot;ns_info locks&quot; command after the server
has been running for some time.  The nsv locks all have names of the
form &quot;nsv:##&quot;.  If you find many lock attempts which did not successed
immediately, try increasing nsvbuckets.






<h2><a name="see_also">SEE ALSO</a></h2>
<p>
<a href="../index.html#key527"> nsd </a>
</body></html>

