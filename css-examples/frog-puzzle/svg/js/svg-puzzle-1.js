// JavaScript Document

var myPuzzle;

function startNewPuzzle(pictureId,svgId,puzzleId,imageId,tileSizeId,dimId,timeId,borderId) {
  myPuzzle = new ImagePuzzle(pictureId,svgId,puzzleId,imageId,tileSizeId,dimId,timeId,borderId)
}

class ImagePuzzle  {

  puzzleImage;

  pictureId;
  svgId;
  puzzleId;
  puzzleDropzone;
  randomMoves;
  randomizeTime;
  borderWidth;
  moveIndex;
  moveTileInterval;
  tileDim;
  puzzleRowsNCols;
  height;
  width;
  tileHeight;
  tileWidth;
  adjustedHeight;
  adjustedWidth;
  puzzleWidth;
  puzzleHeight;
  puzzle;
  tileId;
  tileX;
  tileY;
  tileData;
  emptyX;
  emptyY;
  empty;
  rows;
  cols;
  svg;
  protoRect;

  constructor (pictureId,svgId,puzzleId,imageId,tileSizeId,dimId,timeId,borderId) {

    this.pictureId = pictureId;
    this.svgId = svgId;
    this.puzzleId = puzzleId;
    this.puzzleImage = new Image();
    Log.Notice("Processing form...");
    this.puzzleImage.src = $('#' + imageId).val();
    Log.Notice("Image=" + this.puzzleImage.src);
    this.tileDim = $('#' + tileSizeId).val();
    this.puzzleRowsNCols = $('#'+dimId).val();
    this.randomizeTime = $('#' + timeId).val();
    this.borderWidth = $('#' + borderId).val();
    //image, tileMin, rowsTry, colsTry, border

    this.generatePuzzle2(this.puzzleImage);
  }

  generatePuzzle2 (image) {

    this.height = image.height;
    this.width  = image.width;

    // this will record the moves generated by the randomize function

    this.cols = this.rows = this.puzzleRowsNCols;

    d3.select("#" + this.pictureId)
      .style("width", this.width + "px")
      .style("height", this.height + "px")
      .style("background-image", "url(" + image.src + ")");

    // test out the puzzle dimensions vs minimum
    while (this.cols > 0 && this.width/this.cols < this.tileDim) {
      Log.Notice("cols=" + this.cols + "width/cols=" + this.width/this.cols);
      this.cols--;
    }
    
    if (this.cols == 0) {
      Log.Error("Cols is zero");
      this.cols = 1;
    }
      
    this.tileWidth = Math.floor(this.width/this.cols);
    
    while (this.rows > 0 && this.height/this.rows < this.tileDim) {
      this.rows--;
    }
    
    if (this.rows == 0) {
      Log.Error("Rows is zero");
      this.rows = 1;
    }
    
    this.tileHeight = Math.floor(this.height/this.rows);
    
    this.puzzleWidth =  this.tileWidth * this.cols + (2*this.borderWidth*this.cols);
    this.puzzleHeight =  this.tileHeight * this.rows + (2*this.borderWidth*this.rows);
    
    Log.Notice("tileHeight=" + this.tileHeight + " tileWidth=" + this.tileWidth);
    Log.Notice ("rows=" + this.rows + " cols=" + this.cols);
    

    //Beginning point to change to SVG for puzzle generation

    this.svg = d3.select("#" + this.svgId)
        .attr("width",this.puzzleWidth)
        .attr("height", this.puzzleHeight)
        .attr("viewPort","0 0 " + this.puzzleWidth + " " + this.puzzleHeight);



    this.defs = this.svg.select("defs").html("");
    this.protoRect = this.defs.append("rect")
        .attr("id","proto-1");

    this.puzzle = d3.select('#'+ this.puzzleId)

    this.tileData = new Array();
    this.puzzleDropzone = new Array();
    // create the tileData 
    for (let row = 0; row<this.rows; row++) {
      this.puzzleDropzone[row] = new Array();
      for (let col = 0; col<this.cols; col++) {
        let tmp = new Object();
        tmp.row = row;
        tmp.col = col;
        tmp.tileId = "t-" + row + "-" + col;
        tmp.class = "tile";
        
        tmp.tileX = this.tileWidth * col + (2*this.borderWidth*col);
        tmp.tileY = this.tileHeight * row + (2*this.borderWidth*row); 
        tmp.obj   = this;
        this.tileData[this.tileData.length] = tmp;
        this.puzzleDropzone[row][col] = {left: tmp.tileX, top: tmp.tileY, tileId: tmp.tileId};
      }
    }

    this.puzzle
      .selectAll(".tile")
      .data(this.tileData)
      .enter()
      .append("rect")
      .attr("title",function(d,i) {
        let title = ""
          + "i='" + i 
          +  "', id='" + d.tileId 
          + "', row='" + d.row 
          + "', col='" + d.col 
          + "', bgp ='"
            + ("-" + (d.tileX - (2*d.col*d.obj.borderWidth)))
            + "px " 
            + ("-" + (d.tileY - (2*d.row*d.obj.borderWidth)))
            + "px"
          + "'"
        return title;
      })
      //.html(function(d,i) {return "<span>" + i+ "</span>";})
      .attr("id", function(d,i) {return  d.tileId ;})
      .attr("class", function(d,i) {return d.class;})
      .attr("x", function(d,i) {return d.tileX;})
      .attr("y", function(d,i) {return d.tileY;})
      .attr("height", this.tileHeight)
      .attr("width",this.tileWidth)
      .style("background-image","url(" + image.src + ")")
      .style("background-position",function(d,i) {
        return "" 
          + ("-" + (d.tileX - (2*d.col*d.obj.borderWidth))) 
          + "px " 
          + ("-" + (d.tileY - (2*d.row*d.obj.borderWidth))) 
          + "px";
        }
      );

    // remove the empty piece
    this.emptyY = this.rows-1;
    this.emptyX = 0;
    this.empty = this.puzzleDropzone[this.emptyY][this.emptyX];
    d3.select("#" + this.empty.tileId).remove();
    this.empty.tileId = "empty";

    d3.selectAll(".tile")
      .on("click", this.moveTile );

    this.randomizePuzzle();

    return;
  }

  nextMoves(exclude) {
    let row = this.emptyY;
    let col = this.emptyX;
    let tmpChoices = [1,2,3,4] // go w, e, n, s
    let choices = [];
    let moveType = 'normal'; // other type is jump
    // add to exclude the impossible moves
    if (this.emptyX-1 < 0) {
      // exclude 1
      exclude[exclude.length] = 1;
      moveType = 'jump'
    }
    if (this.emptyX+1 >= this.cols) {
      // exclude 2
      exclude[exclude.length] = 2;
      moveType = 'jump'
    }
    if (this.emptyY-1 < 0) {
      // exclude 3
      exclude[exclude.length] = 3;
      moveType = 'jump'
    }
    if (this.emptyY+1 >= this.rows) {
      // exclude 4
      exclude[exclude.length] = 4;
      moveType = 'jump'
    }

    var found = 0;

    for (var j = 0; j<tmpChoices.length; j++) {
      found = 0;
      for (var i = 0; i<exclude.length; i++) {
          if (exclude[i] == tmpChoices[j]) {
            found = 1;
            break;
          }
      }
      if (found == 0) {
          choices[choices.length] = tmpChoices[j];
      }
    }

    Log.Notice("nextMoves choices=" + choices + " exclude=" + exclude);

    return choices;
  }

  randomizePuzzle() {

    let maxDim = (this.rows<this.cols?this.cols:this.rows);
    maxDim = (maxDim<4?4:maxDim);
    let origSteps = maxDim*this.rows*this.cols;
    let steps = origSteps;
    let rand;
    let dropzone;
    let exclude = [];
    let choices = [];
    this.randomMoves = [];
    // initialize Math.random()
    let index = Math.floor(Math.random(Date.now)*choices.length);

    while (steps > 0) {

      // avoid moving tile back to where it just came from
      choices = this.nextMoves(exclude);
      index = Math.floor(Math.random()*choices.length);

      if (typeof(index) == "number") {
          rand = choices[index];
      } else {
          Log.Notice("index is not a number index=" + index + " typeof(index)=" + typeof(index));
          break;
      }

      if (typeof(rand) != "number") {
          Log.Notice("rand is not a number rand=" + rand + " typeof(rand)=" + typeof(rand) + " index=" + index);
          break;
      }

      Log.Notice("choices=" + choices + " index=" + index + " randvalue=" + rand);

      switch (rand) {
      case 1:  // piece goes w
          if (this.emptyX - 1 >= 0) {
            Log.Notice("Case 1: To y,x=" + this.emptyY + "," 
              + this.emptyX + " From=" + this.emptyY + "," + (this.emptyX-1));

            this.emptyX--;
            exclude = [2];
            this.randomMoves[this.randomMoves.length] = [this.emptyY, this.emptyX];
          }
          break;
      case 2: // piece goes e
          if (this.emptyX+1 < this.cols) {
            Log.Notice("Case 2: To y,x=" + this.emptyY + ","
              + this.emptyX + " From=" + this.emptyY + "," + (this.emptyX+1));
              this.emptyX++;
            exclude = [1];
            this.randomMoves[this.randomMoves.length] = [this.emptyY, this.emptyX];
          }
          break;
      case 3: // piece goes n
          if (this.emptyY - 1 >= 0) {
            Log.Notice("Case 3: To y,x=" + this.emptyY + "," + this.emptyX
              + " From=" + (this.emptyY-1) + "," + this.emptyX);
              this.emptyY--;
            exclude = [4];
            this.randomMoves[this.randomMoves.length] = [this.emptyY, this.emptyX];
          }
          break;
      case 4: // piece goes s
          if (this.emptyY+1 < this.rows) {
            Log.Notice("Case 4: To y,x=" + this.emptyY + ","
              + this.emptyX + " From=" + (this.emptyY+1) + "," + this.emptyX);
            this.emptyY++;
            exclude = [3];
            this.randomMoves[this.randomMoves.length] = [this.emptyY, this.emptyX];
          }
          break;
      default:
          break;
      } // end switch
      // since every step should succeed, we decr steps:
      steps--;
    } // end while
    this.moveIndex = 0;
    this.moveTileInterval = setInterval("myPuzzle.moveTiles()", Math.ceil(1000*this.randomizeTime/(origSteps)));
  }

  moveTiles() {

    if (this.moveIndex >= this.randomMoves.length) {
      clearInterval(this.moveTileInterval);
      return;
    }

    let tile = this.randomMoves[this.moveIndex];
    let tileRow = tile[0];
    let tileCol = tile[1];
    let dropzone = this.puzzleDropzone[tileRow][tileCol];
    let tileId = dropzone.tileId;  
    Log.Notice("In moveTiles() moveIndex=" + this.moveIndex + " tileId=" + tileId);
    //d3.select('#' + tileId)
      //.on("each", moveTile);
    $('#' + tileId).click();

    this.moveIndex++;
  }

  moveTile(d,i,e) {
    let event = d3.event;
    let myObj = d.obj;
    Log.Notice("moving tile.....tileId=" + d.tileId);
    let origRow = d.row;
    let origCol = d.col;

    // figure out which direction the piece is going
    let moveTo = [myObj.rows,myObj.cols];
    let foundMoveTo = false;

    while (true) {

      if (d.row+1 < myObj.rows && myObj.puzzleDropzone[d.row+1][d.col].tileId == "empty") {
        moveTo = [d.row+1, d.col];
        foundMoveTo = true;
        break;
      }
      if (d.row-1 >= 0 && myObj.puzzleDropzone[d.row-1][d.col].tileId == "empty"){
        moveTo = [d.row-1, d.col];
        foundMoveTo = true;
        break;
      }
      if (d.col+1 < myObj.cols && myObj.puzzleDropzone[d.row][d.col+1].tileId == "empty") {
        moveTo = [d.row, d.col+1];
        foundMoveTo = true;
        break;
      }
      if (d.col-1 >= 0 && myObj.puzzleDropzone[d.row][d.col-1].tileId == "empty") {
        moveTo = [d.row, d.col-1];
        foundMoveTo = true;
        break;
      }
      // always exit
      break;
    }

    if (!foundMoveTo) {
      Log.Notice("No place to move");
      return;
    } else {
      Log.Notice("Moving to " + moveTo);
    }

    d.row = moveTo[0];
    d.col = moveTo[1];

    let dropZone = myObj.puzzleDropzone[d.row][d.col];

    if (dropZone.tileId != "empty") {
      // restore current tile
      Log.Notice("trying to move tile into non-empty position row="
        + d.row + " col=" + d.col);
      d.row = origRow;
      d.col = origCol;

    } else {
    
      Log.Notice("Move tile into empty position row=" + d.row 
        + " col=" + d.col + " from row=" + origRow + " col=" + origCol);  

      d3.select(this)
        .transition()
        .duration(250)
        .attr("x", dropZone.left)
        .attr("y", dropZone.top)
      
      // update the tileID stuff here as well
      myObj.puzzleDropzone[d.row][d.col].tileId = d.tileId;
      myObj.puzzleDropzone[origRow][origCol].tileId = "empty";

      Log.Notice("From: dropzone[" + origRow + "][" + origCol + "].tileId=" 
        + myObj.puzzleDropzone[origRow][origCol].tileId );
      Log.Notice("To:   dropzone[" + d.row + "][" + d.col + "].tileId="  
        + myObj.puzzleDropzone[d.row][d.col].tileId );
    }
  }
}