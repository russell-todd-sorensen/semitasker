<!DOCTYPE HTML>
<html lang="en_US">
<head>
<meta charset="utf-8">
<title>Frog Puzzle</title>
<link rel="stylesheet" type="text/css" href="css/frog-puzzle.css" media="all">
<script type="text/javascript" src="http://ic00408/js/jquery-1.7.1.js"></script>
<script type="text/javascript" src="http://ic00408/js/log.js"></script>
<script src="../../../../../../js/d3.v3.js"></script>
<style type="text/css">
/* place any page unique styles here */

#ll {
    width: 80px;
    height: 80px;
    margin: auto;
    padding: 0px;
    border: 5px solid #369;
    background-color: tan;
    background-image: url(images/frog-6.jpg);
    background-origin:content-box;
    background-position: 225px 200px; /* x y */
    background-clip: padding-box;
}

#picture {
    background-color: silver;
    border: 6px solid #369;
    padding: 0;
    margin: 20px;
    display: inline-block;
    background-image: url(images/frog-6.jpg);
    background-clip: padding-box;
}

#puzzle {
    display: inline-block;
    position: relative;
    background-color: silver;
    border: 6px solid #369;
    padding: 0;
    margin: 20px;
}

.tile {
    position: absolute;
    border: 0;
    padding: 0;
    margin: 0;
    background-image: url(images/frog-6.jpg);
    background-clip: padding-box;
    border: 1px solid silver;
}

#show {
    height: 100px;
    width: 200px;
    background-color: #369;
}

</style>
<script>

var frogImage = new Image();
frogImage.src = "images/frog-6.jpg";

var h = frogImage.height;
var w = frogImage.width;

var on = {showId: 0, showInfo: false, toDelete: []};


function generatePuzzle (image) {
	
	var height = image.height;
	var width = image.width;
	var minDim = 50;
	var rows = 5;
	var cols = 5;
	
	var tileHeight, tileWidth;
	var adjustedHeight, adjustedWidth;
	
	d3.select("#picture")
		.style("width", width + "px")
		.style("height", height + "px");
	
	// test out the puzzle dimensions vs minimum
	while (cols > 0 && width/cols < minDim) {
		Log.Notice("cols=" + cols + "width/cols=" + width/cols);
		cols--;
	}
	
	if (cols == 0) {
		Log.Error("Cols is zero");
		cols = 1;
	}
		
	tileWidth = Math.floor(width/cols);
	
	while (rows > 0 && height/rows < minDim) {
		rows--;
	}
	
	if (rows == 0) {
		Log.Error("Rows is zero");
		rows = 1;
	}
	
	tileHeight = Math.floor(height/rows);
	
	var puzzleWidth =  tileWidth * cols;
	var puzzleHeight =  tileHeight * rows;
	
	Log.Notice("tileHeight=" + tileHeight + " tileWidth=" + tileWidth);
	Log.Notice ("rows=" + rows + " cols=" + cols);
	
	var puzzle = d3.select('#puzzle')
	 	.style("width",puzzleWidth + "px")
		.style("height",puzzleHeight + "px");
	var tileId;
	var tileX, tileY;
	
	var tileData = new Array();
	var puzzleDropzone = new Array();
	
	// create the tileData 
	for (var row = 0; row<rows; row++) {
		puzzleDropzone[row] = new Array();
		for (var col = 0; col<cols; col++) {
			var tmp = new Object();
			tmp.row = row;
			tmp.col = col;
			tmp.tileId = "t-" + row + "-" + col;
			tmp.class = "tile";
			
			tmp.tileX = tileWidth * col;
			tmp.tileY = tileHeight * row;
			
			tileData[tileData.length] = tmp;
			//puzzleDropzone[row][col] = {right: tmp.tileX + tileWidth, bottom: tmp.tileY + tileHeight, tileId: tmp.tileId};
			puzzleDropzone[row][col] = {right: tmp.tileX, bottom: tmp.tileY, tileId: tmp.tileId};
		}
	}
	
  puzzle.selectAll(".tile")
	  .data(tileData)
		.enter()
		.append("div")
		.attr("id", function(d,i) {return d.tileId;})
		.attr("class", function(d,i) {return d.class;})
		.style("bottom", function(d,i) {return d.tileY + "px";})
		.style("right", function(d,i) {return d.tileX + "px";})
		.style("height", function(d,i) {return tileHeight + "px";})
		.style("width", function(d,i) {return tileWidth + "px";})
		.style("background-position", function(d,i) {return "" + (d.tileX + tileWidth) + "px " + (d.tileY + tileHeight) + "px"; } );
	
  // remove the empty piece
	var empty = puzzleDropzone[1][cols-3];
	d3.select("#" + empty.tileId).remove();
	empty.tileId = "empty";

	d3.selectAll(".tile")
		.on("mousedown.drag", function(d,i,e) {
			d.startX = d3.event.x;
			d.startY = d3.event.y;
			Log.Notice("dragging x=" + d.startX + " y=" + d.startY );

			return i;
	  })
		.on("mouseover", function(d,i,e) {
			
			var event = d3.event;
			
			d3.select("#show")
				.append("div")
				  .attr("id", "info-" + d.tileId)
					.attr("class", "info")
				  .text("row=" + d.row + " col=" + d.col + " tileId=" + d.tileId);
		})
		.on("mouseout", function(d,i,e) {
			d3.select("#info-" + d.tileId).remove();
		})
		.on("mouseup", function(d,i,e) {
			var me = this;
			var event = d3.event;
			Log.Notice("startX=" + d.startX + " startY=" + d.startY);
			d.endX = event.x;
			d.endY = event.y;
			var diffX = d.startX - d.endX;
			var diffY = d.startY - d.endY;
			
			origRow = d.row;
			origCol = d.col;
			// figure out which direction the piece is going
			if (Math.abs(diffX) > Math.abs(diffY)) {
				Log.Notice("going right or left");
				// going right or left
				if (diffX > 0) {
					// going left
					if (d.col + 1 < cols) {
						d.col++;
					} else {
						return event.stopPropagation();
					}
				} else {
					// going right
					if (d.col - 1 >= 0) {
						d.col--
					} else {
						return event.stopPropagation();
					}
				}
			} else {
					Log.Notice("going up or down");
					if (diffY > 0) {
						// going up
						if (d.row + 1 < rows) {
							d.row++;
						} else {
							return event.stopPropagation();
						}
					} else {
						if (d.row -1 >= 0) {
							d.row--;
						} else {
							return event.stopPropagation();
						}
					}
			}
			
			var dropZone = puzzleDropzone[d.row][d.col];
			if (dropZone.tileId != "empty") {
				// restore current tile
				Log.Notice("trying to move tile into non-empty position row=" + d.row + " col=" + d.col);  
				d.row = origRow;
				d.col = origCol;
				puzzleDropzone[d.row][d.col].row = origRow;
				puzzleDropzone[d.row][d.col].col = origCol;
				return event.stopPropagation();
			} else {
			
				Log.Notice("Move tile into empty position row=" + d.row + " col=" + d.col + " from row=" + origRow + " col=" + origCol);  
				
				d3.select(me)
					.style("botton", dropZone.bottom + "px")
					.style("right", dropZone.right + "px");
				
				// update the tileID stuff here as well
				puzzleDropzone[d.row][d.col].tileId = d.tileId;
				puzzleDropzone[origRow][origCol].tileId = "empty";
				Log.Notice("tileId=" + puzzleDropzone[origRow][origCol].tileId + ", tileRow=" + d.row + ", tileCol=" + d.col);
				
			}
	  });
		return event.stopPropagation();
}

$(document).ready(function() {
	Log.Notice("jQuery Ready!");
	
	var frogImage = new Image();
  frogImage.src = "images/frog-6.jpg";

  var h = frogImage.height;
  var w = frogImage.width;
  
  Log.Notice("frogImage.src=" + frogImage.src);
	Log.Notice("height =" + h + " width=" + w);
	generatePuzzle(frogImage);
	//Log.Hide();
});

</script>
</head>
<body>

<div id="ll"></div>
<div id="picture"></div>
<div id="puzzle"></div>

<div id="show"></div>
</body>
</html>